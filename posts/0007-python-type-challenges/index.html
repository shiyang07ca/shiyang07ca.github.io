<!DOCTYPE html>

<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  
  
    
  
  <meta name="description" content="Python 为什么要需要类型 (1)    - 标注所有参数和返回类型可以更容易理解代码，更易于修改或添加代码  - 在使用库时，可以更容易地检查类型，方便 IDE 代码补全以及检查错误参数  -">

  <title>Python type challenges</title>
  <link rel="icon" type="image/png" sizes="32x32" href="https://shiyang07ca.github.io/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://shiyang07ca.github.io/img/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://shiyang07ca.github.io/img/apple-touch-icon.png">
  
  <style>

  /* light mode colors */
  body {
    --primary-color: #5871a2;
    --primary-pale-color: #5871a233;
    --primary-decoration-color: #5871a210;
    --bg-color: #ffffff;
    --text-color: #2f3030;
    --text-pale-color: #767676;
    --text-decoration-color: #a9a9a9;
    --highlight-mark-color: #5f75b020;

    --callout-note-color: #5871a2;
    --callout-tip-color: #268556;
    --callout-important-color: #885fc9;
    --callout-warning-color: #ab6632;
    --callout-caution-color: #c64e4e;
  }

  /* dark mode colors */
  body.dark {
    --primary-color: #6f8fd1;
    --primary-pale-color: #6f8fd166;
    --primary-decoration-color: #6f8fd112;
    --bg-color: #1c1c1c;
    --text-color: #c1c1c1;
    --text-pale-color: #848484;
    --text-decoration-color: #5f5f5f;
    --highlight-mark-color: #8296cb3b;

    --callout-note-color: #6f8fd1;
    --callout-tip-color: #47976f;
    --callout-important-color: #9776cd;
    --callout-warning-color: #ad7a52;
    --callout-caution-color: #d06161;
  }

  /* typography */
  body {
    --main-font: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
    --code-font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    --homepage-max-width: 768px;
    --main-max-width: 768px;
    --avatar-size: 60px;
    --font-size: 16px;
    --line-height: 1.75;
    --img-border-radius: 0px;
    --detail-border-radius: 0px;
    --dark-mode-img-brightness: 0.75;
    --dark-mode-chart-brightness: 0.75;
    --inline-code-border-radius: 2px;
    --inline-code-bg-color: var(--primary-decoration-color);
    --block-code-border-radius: 0px;
    --block-code-border-color: var(--primary-color);
    --detail-border-color: var(--primary-color);
  }

</style>

  <link rel="stylesheet" href="https://shiyang07ca.github.io/main.css">
  



  
</head>

<body class="post">
  
  <script>
    const theme = sessionStorage.getItem('theme');
    const match = window.matchMedia("(prefers-color-scheme: dark)").matches;
    if ((theme && theme == 'dark') || (!theme && match)) {
      document.body.classList.add('dark');
      const hl = document.querySelector('link#hl');
      if (hl) hl.href = 'https://shiyang07ca.github.io/giallo-dark.css';
    }
  </script>
  
  
<div id="wrapper">
  <div id="blank"></div>
  <aside>
    
    
    <nav>
      <ul>
        
        <li>
          <a class="h2" href="#python-type-challenges">Python type challenges</a>
          
          <ul>
            
            <li>
              <a class="h3" href="#python-wei-shen-me-yao-xu-yao-lei-xing-1">Python 为什么要需要类型 1</a>
            </li>
            
            <li>
              <a class="h3" href="#python-lei-xing-ji-chu">Python 类型基础</a>
            </li>
            
            <li>
              <a class="h3" href="#han-shu">函数</a>
            </li>
            
            <li>
              <a class="h3" href="#lei">类</a>
            </li>
            
            <li>
              <a class="h3" href="#fan-xing-generic">泛型（Generic）</a>
            </li>
            
            <li>
              <a class="h3" href="#typeddict">TypedDict</a>
            </li>
            
            <li>
              <a class="h3" href="#qi-ta">其他</a>
            </li>
            
            <li>
              <a class="h3" href="#todo-xie-bian-ni-bian-bu-bian-covariant-contravariant-invariant">TODO: 协变，逆变，不变(covariant, contravariant, invariant)</a>
            </li>
            
            <li>
              <a class="h3" href="#pai-cha-gong-ju">排查工具</a>
            </li>
            
            <li>
              <a class="h3" href="#sheng-cheng-type-annotation">生成 type annotation</a>
            </li>
            
            <li>
              <a class="h3" href="#yi-xie-lei-xing-jian-cha-gong-ju">一些类型检查工具</a>
            </li>
            
          </ul>
          
        </li>
        
      </ul>
    </nav>
    
    
    <button id="back-to-top" aria-label="back to top">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill="currentColor"></path></svg>
    </button>
    
  </aside>
  <main>
    
<header>
  <nav>
    <a id="back-link" href="https:&#x2F;&#x2F;shiyang07ca.github.io&#x2F;posts">← Back</a>
  </nav>
</header>


    <div>
      
      
      
      
      <div id="copy-cfg" style="display: none;" data-copy-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; height=&quot;24&quot;&gt;&lt;path d=&quot;M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;" data-check-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; height=&quot;24&quot;&gt;&lt;path d=&quot;M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;"></div>
      
      <article class="prose">
        <h1>Python type challenges</h1>
        <div id="post-info">
          <div id="date">
            <span id="publish">2024年10月20日</span>
            </div>

          
          <div id="tags">
            
          </div>
          
        </div>

        
        

        

        <h1 id="python-type-challenges"><a rel="nofollow noreferrer" href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/7">Python type challenges</a><a class="zola-anchor" href="#python-type-challenges" aria-label="Anchor link for: python-type-challenges" style="visibility: hidden;"></a>
</h1>
<h2 id="python-wei-shen-me-yao-xu-yao-lei-xing-1">Python 为什么要需要类型 <a rel="nofollow noreferrer" href="https://bernat.tech/posts/the-state-of-type-hints-in-python/">1</a><a class="zola-anchor" href="#python-wei-shen-me-yao-xu-yao-lei-xing-1" aria-label="Anchor link for: python-wei-shen-me-yao-xu-yao-lei-xing-1" style="visibility: hidden;"></a>
</h2>
<ul>
<li>标注所有参数和返回类型可以更容易理解代码，更易于修改或添加代码</li>
<li>在使用库时，可以更容易地检查类型，方便 IDE 代码补全以及检查错误参数</li>
<li>可以使使用 linter 工具可以提前发现类型错误</li>
<li>运行时数据验证工具，例如：<a rel="nofollow noreferrer" href="https://github.com/pydantic/pydantic">pydantic</a></li>
</ul>
<h3 id="yi-xie-you-yong-de-zi-liao">一些有用的资料<a class="zola-anchor" href="#yi-xie-you-yong-de-zi-liao" aria-label="Anchor link for: yi-xie-you-yong-de-zi-liao" style="visibility: hidden;"></a>
</h3>
<ul>
<li><a rel="nofollow noreferrer" href="https://bernat.tech/posts/the-state-of-type-hints-in-python/">The state of type hints in Python · Tech articles by Bernát Gábor</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/laike9m/Python-Type-Challenges">laike9m/Python-Type-Challenges: Master Python typing (type hints) with interactive online exercises!</a></li>
<li><a rel="nofollow noreferrer" href="https://peps.python.org/pep-0484/">PEP 484 – Type Hints | peps.python.org</a></li>
<li><a rel="nofollow noreferrer" href="https://bruceyuan.com/post/python-type-challenge-basic.html">Python 类型体操训练（一）– 基础篇 | 用代码打点酱油的chaofa</a></li>
</ul>
<h2 id="python-lei-xing-ji-chu">Python 类型基础<a class="zola-anchor" href="#python-lei-xing-ji-chu" aria-label="Anchor link for: python-lei-xing-ji-chu" style="visibility: hidden;"></a>
</h2>
<h3 id="chang-jian-guan-jian-zi">常见关键字<a class="zola-anchor" href="#chang-jian-guan-jian-zi" aria-label="Anchor link for: chang-jian-guan-jian-zi" style="visibility: hidden;"></a>
</h3>
<h4 id="union">Union<a class="zola-anchor" href="#union" aria-label="Anchor link for: union" style="visibility: hidden;"></a>
</h4>
<p><code>Union[X, Y]</code> 等价于 <code>X | Y</code> (3.10 及以上)，意味着满足 <code>X</code> 或 <code>Y</code> 之一。
参数必须是某种类型(<code>X</code> 或 <code>Y</code>)，且至少有一个。</p>
<h4 id="optional">Optional<a class="zola-anchor" href="#optional" aria-label="Anchor link for: optional" style="visibility: hidden;"></a>
</h4>
<p><code>Optional[X]</code> 等价于 <code>X | None</code> （或 <code>Union[X, None]</code> ） 。</p>
<h4 id="typevar">TypeVar<a class="zola-anchor" href="#typevar" aria-label="Anchor link for: typevar" style="visibility: hidden;"></a>
</h4>
<p>可以使用 <code>TypeVar</code> 构造定义它自己的通用容器：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">T = TypeVar(&#x27;T&#x27;)
class Magic(Generic[T]):
      def __init__(self, value: T) -&gt; None:
         self.value : T = value

 def square_values(vars: Iterable[Magic[int]]) -&gt; None:
     v.value = v.value * v.value
</code></pre>
<p><code>TypeVar</code> 还可以通过指定多个类型参数来创建泛型，表示参数可以是这些类型之一：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">T = TypeVar(&#x27;T&#x27;, int, str)  # T 可以是 int 或 str

def add(x: T, y: T) -&gt; T:
    return x + y
</code></pre>
<h4 id="any">Any<a class="zola-anchor" href="#any" aria-label="Anchor link for: any" style="visibility: hidden;"></a>
</h4>
<p>可以使用 <code>Any</code> 类型可以在不需要的地方禁用类型检查：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def foo(item: Any) -&gt; int:
     item.bar()
</code></pre>
<h3 id="lei-xing-bie-ming-typealias">类型别名 (TypeAlias)<a class="zola-anchor" href="#lei-xing-bie-ming-typealias" aria-label="Anchor link for: lei-xing-bie-ming-typealias" style="visibility: hidden;"></a>
</h3>
<p>类型别名是使用 <code>type</code> 语句来定义的，它将创建一个 <code>TypeAliasType</code> 的实例。 在这个
示例中，Vector 和 list[float] 将被静态类型检查器等同处理:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">type Vector = list[float]

def scale(scalar: float, vector: Vector) -&gt; Vector:
    return [scalar * num for num in vector]

# 通过类型检查；浮点数列表是合格的 Vector。
new_vector = scale(2.0, [1.0, -4.2, 5.4])
</code></pre>
<p><code>type</code> 语句是在 Python 3.12 中新增加的。 为了向下兼容，类型别名也可以通过简单的赋
值来创建:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">Vector = list[float]
</code></pre>
<p>也可以用 TypeAlias 标记来显式说明这是一个类型别名：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import TypeAlias

Vector: TypeAlias = list[float]
</code></pre>
<h3 id="newtype">NewType<a class="zola-anchor" href="#newtype" aria-label="Anchor link for: newtype" style="visibility: hidden;"></a>
</h3>
<p><code>NewType</code> 用于创建一个新的类型，它与原始类型具有相同的值，但类型检查器会将其视为
不同的类型。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import NewType

UserId = NewType(&#x27;UserId&#x27;, int)
some_id = UserId(524313)
</code></pre>
<p>静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def get_user_name(user_id: UserId) -&gt; str:
    ...

# 通过类型检查
user_a = get_user_name(UserId(42351))

# 未通过类型检查；整数不能作为 UserId
user_b = get_user_name(-1)
</code></pre>
<blockquote>
<p><strong>备注</strong> 请记住使用类型别名将声明两个类型是相互 等价 的。 使用 type Alias =
Original 将使静态类型检查器在任何情况下都把 Alias 视为与 Original 完全等价。 这
在你想要简化复杂的类型签名时会很有用处。
反之，NewType 声明把一种类型当作另一种类型的 子类型。Derived =
NewType(‘Derived’, Original) 时，静态类型检查器把 Derived 当作 Original 的 子类
，即，Original 类型的值不能用在预期 Derived 类型的位置。这种方式适用于以最小运行
时成本防止逻辑错误。</p>
</blockquote>
<h2 id="han-shu">函数<a class="zola-anchor" href="#han-shu" aria-label="Anchor link for: han-shu" style="visibility: hidden;"></a>
</h2>
<h3 id="ke-diao-yong-dui-xiang-callable">可调用对象（Callable）<a class="zola-anchor" href="#ke-diao-yong-dui-xiang-callable" aria-label="Anchor link for: ke-diao-yong-dui-xiang-callable" style="visibility: hidden;"></a>
</h3>
<p><code>Callable[[int], str]</code> 表示一个接受 <code>int</code> 类型的单个形参并返回一个 <code>str</code> 的函数。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from collections.abc import Callable, Awaitable

def feeder(get_next_item: Callable[[], str]) -&gt; None:
    ...  # 函数体

def async_query(on_success: Callable[[int], None],
                on_error: Callable[[int, Exception], None]) -&gt; None:
    ...  # 函数体

async def on_update(value: str) -&gt; None:
    ...  # 函数体

callback: Callable[[str], Awaitable[None]] = on_update
</code></pre>
<p>如果不确定参数数量，可以使用 <code>Callable[..., ReturnType]</code> 来表示任意数量的参数</p>
<h3 id="paramspec">Paramspec<a class="zola-anchor" href="#paramspec" aria-label="Anchor link for: paramspec" style="visibility: hidden;"></a>
</h3>
<p>ParamSpec 是 Python 3.10 引入的，它允许你在类型提示中使用可变数量和类型的参数。
主要用于以下场景:</p>
<ol>
<li>定义高阶函数(接受或返回其他函数的函数)的类型</li>
<li>保留原始函数的参数签名信息</li>
</ol>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import Callable, ParamSpec, TypeVar

# Before 3.12 you have to write:
# P = ParamSpec(&#x27;P&#x27;)  # 定义 ParamSpec
# R = TypeVar(&#x27;R&#x27;)  # 定义返回类型的 TypeVar

def add_logging[**P, R](f: Callable[P, R]) -&gt; Callable[P, R]:
    def wrapped(*args: P.args, **kwargs: P.kwargs) -&gt; R:
        print(f&quot;Calling {f.__name__}&quot;)
        return f(*args, **kwargs)
    return wrapped

@add_logging
def greet(name: str) -&gt; str:
    return f&quot;Hello, {name}!&quot;

result = greet(&quot;Alice&quot;)
print(result)
</code></pre>
<h3 id="concatenate">Concatenate<a class="zola-anchor" href="#concatenate" aria-label="Anchor link for: concatenate" style="visibility: hidden;"></a>
</h3>
<p>主要用于与 Callable 和 ParamSpec（参数规格）配合使用。它允许我们在类型提示中将多
个参数类型拼接在一起，从而创建更灵活的函数类型提示。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import Concatenate, Callable, ParamSpec, TypeVar

P = ParamSpec(&#x27;P&#x27;)  # 定义一个参数规格
T = TypeVar(&#x27;T&#x27;)    # 定义一个泛型类型

def decorator(func: Callable[Concatenate[int, P], T]) -&gt; Callable[P, T]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; T:
        print(&quot;Adding an integer argument&quot;)
        return func(42, *args, **kwargs)  # 在调用原函数时插入一个整数参数
    return wrapper
</code></pre>
<h3 id="unpack">unpack<a class="zola-anchor" href="#unpack" aria-label="Anchor link for: unpack" style="visibility: hidden;"></a>
</h3>
<p>Python 3.11 开始引入了类型参数展开（Type Parameter Unpacking），可以通过 * 操作
符解包类型参数。这允许你在类型提示中处理变长的参数列表和泛型参数。</p>
<p>Unpack 也可以与 typing.TypedDict 一起使用以便在函数签名中对 **kwargs 进行类型标
注</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

`foo` expects two keyword arguments - `name` of type `str`, and `age` of type `int`.
&quot;&quot;&quot;

from typing import Unpack, TypedDict


class Person(TypedDict):
    name: str
    age: int


def foo(**kwargs: Unpack[Person]):
    ...


## End of your code ##
person: Person = {&quot;name&quot;: &quot;The Meaning of Life&quot;, &quot;age&quot;: 1983}
foo(**person)
foo(**{&quot;name&quot;: &quot;Brian&quot;, &quot;age&quot;: 30})

foo(**{&quot;name&quot;: &quot;Brian&quot;})  # expect-type-error
person2: dict[str, object] = {&quot;name&quot;: &quot;Brian&quot;, &quot;age&quot;: 20}
foo(**person2)  # expect-type-error
foo(**{&quot;name&quot;: &quot;Brian&quot;, &quot;age&quot;: &quot;1979&quot;})  # expect-type-error
</code></pre>
<h3 id="typevartuple">TypeVarTuple<a class="zola-anchor" href="#typevartuple" aria-label="Anchor link for: typevartuple" style="visibility: hidden;"></a>
</h3>
<p>TypeVarTuple 可以定义“变长元组”（variadic tuples）类型。这种类型提示可以捕获多个
类型，并且允许元组长度动态变化。它类似于泛型中的 TypeVar，但 TypeVarTuple 是专门
用于处理可变数量的类型参数的。</p>
<p>TypeVarTuple 用于定义一组任意数量的类型参数，它们可以一起表示一个变长的元组或任
意长的参数列表。</p>
<p>TypeVarTuple 定义一个类型元组，它可以代表任意数量的类型。
Unpack 用于从 TypeVarTuple 中提取类型参数，并应用到函数或类中。</p>
<h4 id="shi-li">示例<a class="zola-anchor" href="#shi-li" aria-label="Anchor link for: shi-li" style="visibility: hidden;"></a>
</h4>
<p>定义一个函数，它接受一个 Tuple，其中的元素可以是任意类型，并返回这个元组。我们可
以使用 TypeVarTuple 来定义这样一个函数：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import TypeVarTuple, Tuple, Unpack

Ts = TypeVarTuple(&#x27;Ts&#x27;)  # 定义一个类型元组 Ts

def my_tuple_func(t: Tuple[Unpack[Ts]]) -&gt; Tuple[Unpack[Ts]]:
    return t

# 我们可以使用这个函数处理不同类型和长度的元组：
print(my_tuple_func((1, &#x27;a&#x27;, 3.14)))  # 输出：(1, &#x27;a&#x27;, 3.14)
print(my_tuple_func((True,)))         # 输出：(True,)
</code></pre>
<p>在这个例子中：</p>
<ul>
<li><code>Ts = TypeVarTuple('Ts')</code> 定义了一个类型变量 <code>Ts</code>，它可以代表一组类型。</li>
<li><code>my_tuple_func</code> 函数接受一个 Tuple，这个元组的类型是由 <code>Unpack[Ts]</code> 解包的。</li>
<li><code>Tuple[Unpack[Ts]]</code> 表示这个元组可以包含多个类型。</li>
</ul>
<h4 id="shi-li-2">示例 2<a class="zola-anchor" href="#shi-li-2" aria-label="Anchor link for: shi-li-2" style="visibility: hidden;"></a>
</h4>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Define an `Array` type that supports element-wise addition of arrays with identical dimensions and types.
&quot;&quot;&quot;

from typing import Generic, TypeVar, TypeVarTuple, assert_type

T = TypeVar(&quot;T&quot;)
Ts = TypeVarTuple(&quot;Ts&quot;)


class Array(Generic[*Ts]):
    def __add__(self, other: &quot;Array[*Ts]&quot;) -&gt; &quot;Array[*Ts]&quot;:
        ...


## End of your code ##
from typing import assert_type

a: Array[float, int] = Array()
b: Array[float, int] = Array()
assert_type(a + b, Array[float, int])

c: Array[float, int, str] = Array()
assert_type(a + c, Array[float, int, str])  # expect-type-error
</code></pre>
<hr />
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">P = ParamSpec(&#x27;P&#x27;)
R = TypeVar(&#x27;R&#x27;)

def add_logging(f: Callable[P, R]) -&gt; Callable[P, R]:
    ...
</code></pre>
<h3 id="typeguard">TypeGuard<a class="zola-anchor" href="#typeguard" aria-label="Anchor link for: typeguard" style="visibility: hidden;"></a>
</h3>
<p><code>TypeGuard</code> 是一种类型提示，用于告诉类型检查器某个函数在运行时能够对变量的类型进
行校验和收缩。它通常用于类型推断工具（例如 <code>mypy</code>）来缩小类型范围。</p>
<p>假设我们有一个函数 <code>is_str_list</code>，它接受一个 <code>list</code> 并检查该列表中的所有元素是否都是
字符串。我们希望在通过该检查后，类型检查器能够推断出列表是由字符串组成的。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import List, TypeGuard, Union

def is_str_list(values: List[Union[str, int]]) -&gt; TypeGuard[List[str]]:
    return all(isinstance(v, str) for v in values)

# 使用示例
my_list: List[Union[str, int]] = [&quot;a&quot;, &quot;b&quot;, 1]

if is_str_list(my_list):
    # 这里类型检查器会推断 my_list 的类型为 List[str]
    print(&quot;All elements are strings&quot;)
</code></pre>
<p>在这个例子中：</p>
<p><code>is_str_list</code> 是一个自定义类型守卫函数，使用 <code>TypeGuard</code> 来标注返回值。
返回类型 <code>TypeGuard[List[str]]</code> 告诉类型检查器，如果 <code>is_str_list</code> 返回 <code>True</code>，
则传入的 <code>values</code> 类型会被认为是 <code>List[str]</code>。</p>
<p>因此，当我们在 <code>if</code> 语句中调用 <code>is_str_list</code> 后，<code>my_list</code> 的类型会自动缩小到
<code>List[str]</code>，而不再是最初的 <code>List[Union[str, int]]</code>。</p>
<h2 id="lei">类<a class="zola-anchor" href="#lei" aria-label="Anchor link for: lei" style="visibility: hidden;"></a>
</h2>
<h3 id="classvar">ClassVar<a class="zola-anchor" href="#classvar" aria-label="Anchor link for: classvar" style="visibility: hidden;"></a>
</h3>
<p><code>ClassVar</code> 注解是指，给定属性应当用作类变量，而不应设置在类实例上。用法如下：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">class Starship:
    stats: ClassVar[dict[str, int]] = {} # 类变量
    damage: int = 10                     # 实例变量
</code></pre>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Class `Foo` has a class variable `bar`, which is an integer.
&quot;&quot;&quot;
from typing import ClassVar


class Foo:
    bar: ClassVar[int]
    &quot;&quot;&quot;Hint: No need to write __init__&quot;&quot;&quot;


## End of your code ##
Foo.bar = 1
Foo.bar = &quot;1&quot;  # expect-type-error
Foo().bar = 1  # expect-type-error
</code></pre>
<h3 id="self">Self<a class="zola-anchor" href="#self" aria-label="Anchor link for: self" style="visibility: hidden;"></a>
</h3>
<p>表示当前闭包内的类</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import Self, reveal_type

class Foo:
    def return_self(self) -&gt; Self:
        ...
        return self

class SubclassOfFoo(Foo): pass

reveal_type(Foo().return_self())  # 揭示的类型为 &quot;Foo&quot;
reveal_type(SubclassOfFoo().return_self())  # 揭示的类型为 &quot;SubclassOfFoo&quot;
</code></pre>
<p>此注解在语法上等价于以下代码，但形式更为简洁：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import TypeVar

Self = TypeVar(&quot;Self&quot;, bound=&quot;Foo&quot;)

class Foo:
    def return_self(self: Self) -&gt; Self:
        ...
        return self
</code></pre>
<p>通常来说，如果某些内容返回 <code>self</code>，如上面的示例所示，您应该使用 <code>Self</code> 作为返回
值注解。如果 <code>Foo.return_self</code> 被注解为返回 <code>"Foo"</code>，那么类型检查器将推断从
<code>SubclassOfFoo.return_self</code> 返回的对象是 <code>Foo</code> 类型，而不是 <code>SubclassOfFoo</code>。</p>
<p>challenge:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

`return_self` should return an instance of the same type as the current enclosed class.
&quot;&quot;&quot;

from typing import Self


class Foo:
    def return_self(self) -&gt; Self:
        ...


# Another solution using TypeVar
# from typing import TypeVar
#
# T = TypeVar(&#x27;T&#x27;, bound=&#x27;Foo&#x27;)
#
# class Foo:
#     def return_self(self: T) -&gt; T:
#         ...


## End of your code ##
class SubclassOfFoo(Foo):
    pass


f: Foo = Foo().return_self()
sf: SubclassOfFoo = SubclassOfFoo().return_self()

sf: SubclassOfFoo = Foo().return_self()  # expect-type-error
</code></pre>
<h2 id="fan-xing-generic">泛型（Generic）<a class="zola-anchor" href="#fan-xing-generic" aria-label="Anchor link for: fan-xing-generic" style="visibility: hidden;"></a>
</h2>
<h3 id="typevar-1">TypeVar<a class="zola-anchor" href="#typevar-1" aria-label="Anchor link for: typevar-1" style="visibility: hidden;"></a>
</h3>
<p><code>TypeVar</code> 可以用来定义一个类型变量，它可以代表任意类型，并且可以在多个地方重用。</p>
<p>泛型函数和类可以通过使用 <code>类型形参语法</code> 来实现参数化:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from collections.abc import Sequence

def first[T](l: Sequence[T]) -&gt; T:  # 函数是 TypeVar &quot;T&quot; 泛型
    return l[0]
</code></pre>
<p><code>TypeVar</code> 提供 <code>bound</code> 参数可以约束它只能是某种类型的子类。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">
from typing import TypeVar

# T 必须是 int 或其子类
T = TypeVar(&#x27;T&#x27;, bound=int)

def double(x: T) -&gt; T:
    return x * 2
</code></pre>
<h3 id="fan-xing-han-shu-generic-functions">泛型函数（Generic Functions）<a class="zola-anchor" href="#fan-xing-han-shu-generic-functions" aria-label="Anchor link for: fan-xing-han-shu-generic-functions" style="visibility: hidden;"></a>
</h3>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import TypeVar

T = TypeVar(&#x27;T&#x27;)  # 定义一个泛型 T

def identity(x: T) -&gt; T:
    return x

# &gt;= 3.12 推荐写法
def identity[T](x: T) -&gt; T:
    return x
</code></pre>
<h3 id="fan-xing-lei">泛型类<a class="zola-anchor" href="#fan-xing-lei" aria-label="Anchor link for: fan-xing-lei" style="visibility: hidden;"></a>
</h3>
<p>在泛型类中，类的属性和方法可以适应不同的数据类型。通过 Generic 类，我们可以将类
声明为泛型类。</p>
<h4 id="fan-xing-lei-ding-yi">泛型类定义<a class="zola-anchor" href="#fan-xing-lei-ding-yi" aria-label="Anchor link for: fan-xing-lei-ding-yi" style="visibility: hidden;"></a>
</h4>
<p>例如，我们可以定义一个简单的容器类，它能够存储任意类型的数据：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from logging import Logger

# `T` 是类体内部有效的类型
class LoggedVar[T]:
    def __init__(self, value: T, name: str, logger: Logger) -&gt; None:
        self.name = name
        self.logger = logger
        self.value = value

    def set(self, new: T) -&gt; None:
        self.log(&#x27;Set &#x27; + repr(self.value))
        self.value = new

    def get(self) -&gt; T:
        self.log(&#x27;Get &#x27; + repr(self.value))
        return self.value

    def log(self, message: str) -&gt; None:
        self.logger.info(&#x27;%s: %s&#x27;, self.name, message)
</code></pre>
<p>泛型类隐式继承自 <code>Generic</code>。为了与 Python 3.11 及更低版本兼容，也允许显式地从
<code>Generic</code> 继承以表示泛型类：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import TypeVar, Generic

T = TypeVar(&#x27;T&#x27;)

class LoggedVar(Generic[T]):
    ...
</code></pre>
<h3 id="fan-xing-he-ji-cheng">泛型和继承<a class="zola-anchor" href="#fan-xing-he-ji-cheng" aria-label="Anchor link for: fan-xing-he-ji-cheng" style="visibility: hidden;"></a>
</h3>
<p>在面向对象编程中，泛型类可以与继承结合使用，允许子类继承父类的泛型行为。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import Generic, TypeVar

T = TypeVar(&#x27;T&#x27;)

class Animal(Generic[T]):
    def speak(self, sound: T) -&gt; None:
        print(f&quot;The animal says {sound}&quot;)

class Dog(Animal[str]):
    pass

dog = Dog()
dog.speak(&quot;woof&quot;)  # 输出：The animal says woof
</code></pre>
<p>在这个例子中，<code>Animal</code> 是一个泛型类，<code>Dog</code> 继承了 <code>Animal</code>，并将泛型 <code>T</code> 限定为
<code>str</code> 类型。</p>
<h3 id="overload">overload<a class="zola-anchor" href="#overload" aria-label="Anchor link for: overload" style="visibility: hidden;"></a>
</h3>
<p><code>@overload</code> 装饰器可以用来声明同一函数的多个版本，每个版本有不同的参数类型和返回值
类型，但在运行时不会实际执行。mypy 会根据参数类型来推断正确的类型签名。</p>
<p>非 <code>@overload</code> 装饰的定义将在运行时使用但应被类型检查器忽略。在运行时，直接调用以
<code>@overload</code> 装饰的函数将引发 NotImplementedError。</p>
<p>challenge:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:
`process` is a function that takes one argument `response`
- When `response` is bytes, `process` returns a string
- When `response` is an integer, `process` returns tuple[int, str]
- When `response` is None, `process` returns None
&quot;&quot;&quot;
from typing import overload


@overload
def process(response: None) -&gt; None:
    ...


@overload
def process(response: int) -&gt; tuple[int, str]:
    ...


@overload
def process(response: bytes) -&gt; str:
    ...


def process(response: int | bytes | None) -&gt; str | None | tuple[int, str]:
    ...


## End of your code ##
from typing import assert_type

assert_type(process(b&quot;42&quot;), str)
assert_type(process(42), tuple[int, str])
assert_type(process(None), None)

assert_type(process(42), str)  # expect-type-error
assert_type(process(None), str)  # expect-type-error
assert_type(process(b&quot;42&quot;), tuple[int, str])  # expect-type-error
assert_type(process(None), tuple[int, str])  # expect-type-error
assert_type(process(42), str)  # expect-type-error
assert_type(process(None), str)  # expect-type-error
</code></pre>
<h3 id="protocol">Protocol<a class="zola-anchor" href="#protocol" aria-label="Anchor link for: protocol" style="visibility: hidden;"></a>
</h3>
<p>用于定义“结构化子类型”（structural subtyping），也称为“鸭子类型”。<code>Protocol</code>  允
许我们通过“接口”来定义一个类型，而不强制要求对象必须显式继承这些接口。只要一个对
象实现了所需的方法或属性，它就可以被认为符合某个 <code>Protocol</code>。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:
    Define a protocol for class `SupportsQuack` that supports a &quot;quack&quot; method.
&quot;&quot;&quot;

from typing import Protocol


class SupportsQuack(Protocol):
    def quack(self) -&gt; None:
        ...


## End of your code ##
class Duck:
    def quack(self) -&gt; None:
        print(&quot;quack!&quot;)


class Dog:
    def bark(self) -&gt; None:
        print(&quot;bark!&quot;)


duck: SupportsQuack = Duck()
dog: SupportsQuack = Dog()  # expect-type-error
</code></pre>
<h3 id="callable-protocol">callable-protocol<a class="zola-anchor" href="#callable-protocol" aria-label="Anchor link for: callable-protocol" style="visibility: hidden;"></a>
</h3>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Define a callable type that accepts a string parameter called `name` and returns None.
&quot;&quot;&quot;
from typing import Protocol


class SingleStringInput(Protocol):
    def __call__(self, name: str) -&gt; None:
        ...


## End of your code ##
def accept_single_string_input(func: SingleStringInput) -&gt; None:
    func(name=&quot;name&quot;)


def string_name(name: str) -&gt; None:
    ...


def string_value(value: str) -&gt; None:
    ...


def return_string(name: str) -&gt; str:
    return name


accept_single_string_input(string_name)
accept_single_string_input(string_value)  # expect-type-error
accept_single_string_input(return_string)  # expect-type-error
</code></pre>
<h2 id="typeddict">TypedDict<a class="zola-anchor" href="#typeddict" aria-label="Anchor link for: typeddict" style="visibility: hidden;"></a>
</h2>
<p>TypedDict 声明一个字典类型，字典定义一个具有特定键和值类型的字典结构，可以像定义
类一样定义字典的键和值的类型，确保字典的键和值符合预期。 可以使用 NotRequired 将
单独的键标记为非必要。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Define a class `Student` that represents a dictionary with three keys:
- name, a string
- age, an integer
- school, a string
&quot;&quot;&quot;
from typing import TypedDict

class Student(TypedDict):
    name: str
    age: int
    school: str

a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}
a: Student = {&quot;name&quot;: 1, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {(1,): &quot;Tom&quot;, &quot;age&quot;: 2, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: &quot;2&quot;, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 2}  # expect-type-error
assert Student(name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;) == dict(
    name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;
)
</code></pre>
<p>默认情况下，所有的键都必须出现在一个 TypedDict 中。可以使用 NotRequired 将单独
的键标记为非必要</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Define a class `Student` that represents a dictionary with three keys:
- name, a string
- age, an integer
- school, a string

Note: school can be optional
&quot;&quot;&quot;

from typing import TypedDict, NotRequired

class Student(TypedDict):
    name: str
    age: int
    school: NotRequired[str]

a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 15}
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}
a: Student = {&quot;name&quot;: 1, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {(1,): &quot;Tom&quot;, &quot;age&quot;: 2, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: &quot;2&quot;, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;z&quot;: &quot;Tom&quot;, &quot;age&quot;: 2}  # expect-type-error
assert Student(name=&quot;Tom&quot;, age=15) == dict(name=&quot;Tom&quot;, age=15)
assert Student(name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;) == dict(
    name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;
)

</code></pre>
<p>使用 total=False 时，TypedDict 中单独的键可以使用 Required 标记为必要的</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Define a class `Person` that represents a dictionary with five string keys:
    name, age, gender, address, email

The value of each key must be the specified type:
    name - str, age - int, gender - str, address - str, email - str

Note: Only `name` is required
&quot;&quot;&quot;

from typing import TypedDict, Required


class Person(TypedDict, total=False):
    name: Required[str]
    age: int
    gender: str
    address: str
    email: str


# Alternative soltion:
#
# Person = TypedDict(&#x27;Person&#x27;, {
#     name: Required[str],
#     age: int,
#     gender: str,
#     address: str,
#     email: str,
# }, total=False):

## End of your code ##
a: Person = {
    &quot;name&quot;: &quot;Capy&quot;,
    &quot;age&quot;: 1,
    &quot;gender&quot;: &quot;Male&quot;,
    &quot;address&quot;: &quot;earth&quot;,
    &quot;email&quot;: &quot;capy@bara.com&quot;,
}
a: Person = {&quot;name&quot;: &quot;Capy&quot;}
a: Person = {&quot;age&quot;: 1, &quot;gender&quot;: &quot;Male&quot;, &quot;address&quot;: &quot;&quot;, &quot;email&quot;: &quot;&quot;} # expect-type-error
</code></pre>
<h2 id="qi-ta">其他<a class="zola-anchor" href="#qi-ta" aria-label="Anchor link for: qi-ta" style="visibility: hidden;"></a>
</h2>
<h3 id="literal">Literal<a class="zola-anchor" href="#literal" aria-label="Anchor link for: literal" style="visibility: hidden;"></a>
</h3>
<p>特殊类型注解形式，用于定义“字面值类型”。</p>
<p>Literal 可以用来向类型检查器说明被注解的对象具有与所提供的字面量之一相同的值。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def validate_simple(data: Any) -&gt; Literal[True]:  # 总是返回 True
    ...

type Mode = Literal[&#x27;r&#x27;, &#x27;rb&#x27;, &#x27;w&#x27;, &#x27;wb&#x27;]
def open_helper(file: str, mode: Mode) -&gt; str:
    ...

open_helper(&#x27;&#x2F;some&#x2F;path&#x27;, &#x27;r&#x27;)      # 通过类型检查
open_helper(&#x27;&#x2F;other&#x2F;path&#x27;, &#x27;typo&#x27;)  # 类型检查错误
</code></pre>
<h3 id="literalstring">LiteralString<a class="zola-anchor" href="#literalstring" aria-label="Anchor link for: literalstring" style="visibility: hidden;"></a>
</h3>
<p>只包括字符串字面值的的特殊类型。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def run_query(sql: LiteralString) -&gt; None:
    ...

def caller(arbitrary_string: str, literal_string: LiteralString) -&gt; None:
    run_query(&quot;SELECT * FROM students&quot;)  # 可以
    run_query(literal_string)  # 可以
    run_query(&quot;SELECT * FROM &quot; + literal_string)  # 可以
    run_query(arbitrary_string)  # 类型检查器错误
    run_query(  # 类型检查器错误
        f&quot;SELECT * FROM students WHERE name = {arbitrary_string}&quot;
    )
</code></pre>
<p>LiteralString 对于会因用户可输入任意字符串而导致问题的敏感 API 很有用。例如，上
述两处导致类型检查器报错的代码可能容易被 SQL 注入攻击。</p>
<h3 id="zhuang-shi-qi-decorator">装饰器（decorator）<a class="zola-anchor" href="#zhuang-shi-qi-decorator" aria-label="Anchor link for: zhuang-shi-qi-decorator" style="visibility: hidden;"></a>
</h3>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

定义一个装饰器，它包装一个函数并返回一个具有相同签名的函数。
&quot;&quot;&quot;
from typing import Callable, TypeVar

# For Python &lt; 3.12
#
# T = TypeVar(&quot;T&quot;, bound=Callable)
#
# def decorator(func: T) -&gt; T:
#     return func


# For Python &gt;= 3.12
def decorator[T: Callable](func: T) -&gt; T:
    return func


## End of your code ##
@decorator
def foo(a: int, *, b: str) -&gt; None:
    ...


@decorator
def bar(c: int, d: str) -&gt; None:
    ...


foo(1, b=&quot;2&quot;)
bar(c=1, d=&quot;2&quot;)

foo(1, &quot;2&quot;)  # expect-type-error
foo(a=1, e=&quot;2&quot;)  # expect-type-error
decorator(1)  # expect-type-error
</code></pre>
<ul>
<li>TODO:</li>
</ul>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

定义一个装饰器，它包装一个函数并返回一个具有相同签名的函数。
这个装饰器接受一个名为 `message` 的字符串类型参数。
&quot;&quot;&quot;
from collections.abc import Callable
from typing import TypeVar

# For Python &lt; 3.12
#
# T = TypeVar(&quot;T&quot;, bound=Callable)
#
# def decorator(message: str) -&gt; Callable[[T], T]:
#     return func


# For Python &gt;= 3.12
def decorator[T: Callable](message: str) -&gt; Callable[[T], T]:
    ...


## End of your code ##
@decorator(message=&quot;x&quot;)
def foo(a: int, *, b: str) -&gt; None:
    ...


@decorator  # expect-type-error
def bar(a: int, *, b: str) -&gt; None:
    ...


foo(1, b=&quot;2&quot;)
foo(1, &quot;2&quot;)  # expect-type-error
foo(a=1, e=&quot;2&quot;)  # expect-type-error
decorator(1)  # expect-type-error
</code></pre>
<h3 id="miao-shu-qi-descriptor">描述器（descriptor）<a class="zola-anchor" href="#miao-shu-qi-descriptor" aria-label="Anchor link for: miao-shu-qi-descriptor" style="visibility: hidden;"></a>
</h3>
<p><code>Self</code> 是一个特殊类型，表示当前闭包内的类。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import Self, reveal_type

class Foo:
    def return_self(self) -&gt; Self:
        ...
        return self

class SubclassOfFoo(Foo): pass

reveal_type(Foo().return_self())  # 揭示的类型为 &quot;Foo&quot;
reveal_type(SubclassOfFoo().return_self())  # 揭示的类型为 &quot;SubclassOfFoo&quot;
</code></pre>
<p>此注解在语法上等价于以下代码，但形式更为简洁：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import TypeVar

Self = TypeVar(&quot;Self&quot;, bound=&quot;Foo&quot;)

class Foo:
    def return_self(self: Self) -&gt; Self:
        ...
        return self
</code></pre>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Create a descriptor and annotate the __get__ method.
&quot;&quot;&quot;

from typing import Any, Self, overload


class Descriptor:
    # 如果 instance 是 None,表示是通过类访问的，返回描述符自身 (self)
    @overload
    def __get__(self, instance: None, owner: type) -&gt; Self:
        ...

    # 通过实例访问的，返回一个字符串 &quot;描述符值&quot;
    @overload
    def __get__(self, instance: Any, owner: type) -&gt; str:
        ...

    def __get__(self, instance: Any, owner: type) -&gt; Self | str:
        ...


## End of your code ##
class TestClass:
    a = Descriptor()


def descriptor_self(x: Descriptor) -&gt; None:
    ...


def string_value(x: str) -&gt; None:
    ...


descriptor_self(TestClass.a)
string_value(TestClass().a)
descriptor_self(TestClass().a)  # expect-type-error
string_value(TestClass.a)  # expect-type-error
</code></pre>
<h3 id="sheng-cheng-qi-generator">生成器（generator）<a class="zola-anchor" href="#sheng-cheng-qi-generator" aria-label="Anchor link for: sheng-cheng-qi-generator" style="visibility: hidden;"></a>
</h3>
<p>生成器可以使用泛型类型 <code>Generator[YieldType, SendType, ReturnType]</code> 来标。 例如:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def echo_round() -&gt; Generator[int, float, str]:
    sent = yield 0
    while sent &gt;= 0:
        sent = yield round(sent)
    return &#x27;Done&#x27;
</code></pre>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

`gen` is a generator that yields a integer, and can accept a string sent to it.
It does not return anything.
&quot;&quot;&quot;

from collections.abc import Generator


def gen() -&gt; Generator[int, str, None]:
    &quot;&quot;&quot;You don&#x27;t need to implement it&quot;&quot;&quot;
    ...


## End of your code ##
from typing import assert_type

generator = gen()
assert_type(next(generator), int)
generator.send(&quot;sss&quot;)
generator.send(3)  # expect-type-error
</code></pre>
<h3 id="never">never<a class="zola-anchor" href="#never" aria-label="Anchor link for: never" style="visibility: hidden;"></a>
</h3>
<p>Never 和 NoReturn 代表 底类型(Bottom Type)，一种没有成员的类型。
它们可被用于指明一个函数绝不会返回，例如 sys.exit():</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import Never  # 或 NoReturn

def stop() -&gt; Never:
    raise RuntimeError(&#x27;no way&#x27;)
</code></pre>
<p>或者用于定义一个绝不应被调用的函数，因为不存在有效的参数，例如 assert_never():</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import Never  # 或 NoReturn

def never_call_me(arg: Never) -&gt; None:
    pass

def int_or_str(arg: int | str) -&gt; None:
    never_call_me(arg)  # 类型检查器错误
    match arg:
        case int():
            print(&quot;It&#x27;s an int&quot;)
        case str():
            print(&quot;It&#x27;s a str&quot;)
        case _:
            never_call_me(arg)  # OK, arg is of type Never (or NoReturn)
</code></pre>
<p>Never 和 NoReturn 在类型系统中具有相同的含义并且静态类型检查器会以相同的方式对待这两者。</p>
<h3 id="buffer">buffer<a class="zola-anchor" href="#buffer" aria-label="Anchor link for: buffer" style="visibility: hidden;"></a>
</h3>
<ul>
<li>https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects</li>
</ul>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">&quot;&quot;&quot;
TODO:

Annotate the function `read_buffer`, which accepts anything that is a buffer.

See https:&#x2F;&#x2F;docs.python.org&#x2F;3.12&#x2F;reference&#x2F;datamodel.html#object.__buffer__
&quot;&quot;&quot;

from collections.abc import Buffer


def read_buffer(b: Buffer):
    ...


## End of your code ##

from array import array


class MyBuffer:
    def __init__(self, data: bytes):
        self.data = bytearray(data)
        self.view = None

    def __buffer__(self, flags: int) -&gt; memoryview:
        self.view = memoryview(self.data)
        return self.view


read_buffer(b&quot;foo&quot;)
read_buffer(memoryview(b&quot;foo&quot;))
read_buffer(array(&quot;l&quot;, [1, 2, 3, 4, 5]))
read_buffer(MyBuffer(b&quot;foo&quot;))
read_buffer(&quot;foo&quot;)  # expect-type-error
read_buffer(1)  # expect-type-error
read_buffer([&quot;foo&quot;])  # expect-type-error
</code></pre>
<h2 id="todo-xie-bian-ni-bian-bu-bian-covariant-contravariant-invariant">TODO: 协变，逆变，不变(covariant, contravariant, invariant)<a class="zola-anchor" href="#todo-xie-bian-ni-bian-bu-bian-covariant-contravariant-invariant" aria-label="Anchor link for: todo-xie-bian-ni-bian-bu-bian-covariant-contravariant-invariant" style="visibility: hidden;"></a>
</h2>
<h2 id="pai-cha-gong-ju">排查工具<a class="zola-anchor" href="#pai-cha-gong-ju" aria-label="Anchor link for: pai-cha-gong-ju" style="visibility: hidden;"></a>
</h2>
<h3 id="shi-yong-reveal-type-cha-kan-tui-duan-lei-xing">使用 <code>reveal_type</code> 查看推断类型<a class="zola-anchor" href="#shi-yong-reveal-type-cha-kan-tui-duan-lei-xing" aria-label="Anchor link for: shi-yong-reveal-type-cha-kan-tui-duan-lei-xing" style="visibility: hidden;"></a>
</h3>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">a = [4]
reveal_type(a)         # -&gt; error: Revealed type is &#x27;builtins.list[builtins.int*]&#x27;
</code></pre>
<h3 id="shi-yong-cast-lai-qiang-zhi-zhi-ding-lei-xing">使用 <code>cast</code> 来强制指定类型：<a class="zola-anchor" href="#shi-yong-cast-lai-qiang-zhi-zhi-ding-lei-xing" aria-label="Anchor link for: shi-yong-cast-lai-qiang-zhi-zhi-ding-lei-xing" style="visibility: hidden;"></a>
</h3>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from typing import List, cast
a = [4]
b = cast(List[int], a) # passes fine
c = cast(List[str], a) # type: List[str] # passes fine (no runtime check)
reveal_type(c)         # -&gt; error: Revealed type is &#x27;builtins.list[builtins.str]&#x27;
</code></pre>
<h3 id="shi-yong-lei-xing-hu-lue-biao-ji-jin-yong-yi-xing-zhong-de-cuo-wu">使用类型忽略标记禁用一行中的错误：<a class="zola-anchor" href="#shi-yong-lei-xing-hu-lue-biao-ji-jin-yong-yi-xing-zhong-de-cuo-wu" aria-label="Anchor link for: shi-yong-lei-xing-hu-lue-biao-ji-jin-yong-yi-xing-zhong-de-cuo-wu" style="visibility: hidden;"></a>
</h3>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">x = confusing_function() # type: ignore # see mypy&#x2F;issues&#x2F;1167
</code></pre>
<h2 id="sheng-cheng-type-annotation">生成 type annotation<a class="zola-anchor" href="#sheng-cheng-type-annotation" aria-label="Anchor link for: sheng-cheng-type-annotation" style="visibility: hidden;"></a>
</h2>
<ol>
<li><code>mypy stubgen</code> <a rel="nofollow noreferrer" href="https://github.com/python/mypy/blob/master/mypy/stubgen.py">mypy/mypy/stubgen.py at master · python/mypy</a></li>
<li><code>monkeytype</code> <a rel="nofollow noreferrer" href="https://github.com/Instagram/MonkeyType">Instagram/MonkeyType: A Python library that generates static type annotations by collecting runtime types</a></li>
</ol>
<h2 id="yi-xie-lei-xing-jian-cha-gong-ju">一些类型检查工具<a class="zola-anchor" href="#yi-xie-lei-xing-jian-cha-gong-ju" aria-label="Anchor link for: yi-xie-lei-xing-jian-cha-gong-ju" style="visibility: hidden;"></a>
</h2>
<ol>
<li><a rel="nofollow noreferrer" href="https://mypy-lang.org/">mypy - Optional Static Typing for Python</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/microsoft/pyright">microsoft/pyright: Static Type Checker for Python</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/facebook/pyre-check">facebook/pyre-check: Performant type-checking for python.</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/google/pytype">google/pytype: A static type analyzer for Python code</a></li>
</ol>
<hr />

      </article>

      
      

      
      
    </div>

    


<footer>
  <div class="left">
    <div class="copyright">
      © 2024-2026 Shiyang
      
      <span>|</span>
      Built with <a href="https://www.getzola.org" rel="noreferrer" target="_blank">zola</a> and <a href="https://github.com/isunjn/serene" rel="noreferrer" target="_blank">serene</a>
      
    </div>
  </div>

  <div class="right">
    
    
      
    
    
    <a id="rss-btn" href="https://shiyang07ca.github.io/feed.xml">RSS</a>
    
    

    
    
    
    <button id="theme-toggle" aria-label="theme switch">
      <span class="moon-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg></span>
      <span class="sun-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg></span>
    </button>
    
  </div>
</footer>




<dialog id="rss-mask">
  <div>
    <a href="https:&#x2F;&#x2F;shiyang07ca.github.io&#x2F;feed.xml">https:&#x2F;&#x2F;shiyang07ca.github.io&#x2F;feed.xml</a>
    
    
    <button autofocus aria-label="copy" data-link="https:&#x2F;&#x2F;shiyang07ca.github.io&#x2F;feed.xml" data-copy-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; height=&quot;24&quot;&gt;&lt;path d=&quot;M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;" data-check-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; height=&quot;24&quot;&gt;&lt;path d=&quot;M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;" >
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>
    </button>
  </div>
</dialog>



  </main>
</div>

  
<script src="/js/lightense.min.js"></script>


  <script src="https://shiyang07ca.github.io/js/main.js"></script>
</body>

</html>
