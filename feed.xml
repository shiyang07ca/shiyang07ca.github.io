<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/shiyang07ca/shiyang07ca.github.io</id><title>RSS feed of shiyang07ca's shiyang07ca.github.io</title><updated>2025-07-26T04:43:00.155221+00:00</updated><link href="https://github.com/shiyang07ca/shiyang07ca.github.io"/><link href="https://raw.githubusercontent.com/shiyang07ca/shiyang07ca.github.io/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/10</id><title>牛羊肉类</title><updated>2025-07-26T04:43:00.560596+00:00</updated><content type="html"><![CDATA[<h1>红烧牛窝骨</h1>
<h2>主配料</h2>
<ul>
<li>牛窝骨，胡萝卜</li>
</ul>
<h2>做法</h2>
<ul>
<li>牛窝骨焯水去浮沫，加葱姜料酒大料炖熟改刀切小块</li>
<li>锅中加油，加葱姜大料甜面酱煸炒，加酱油牛窝骨煸炒</li>
<li>加牛肉原汤，盐味精糖，牛窝骨胡萝卜炖 25 分钟</li>
<li>加水淀粉勾芡，加花椒油出锅</li>
</ul>
<h1>红焖羊排（村驴）</h1>
<h2>主配料</h2>
<ul>
<li>羊排，胡萝卜</li>
<li>香料：桂皮 2g，香叶 3 片，草果皮 1 个，良姜 2g，白蔻 3 个，白芷 5g，毛砂仁 3g，丁香 3 粒，白胡椒粒 3g，花椒粒 3g，甘草 2 粒，孜然粒 10g，干辣椒 10g</li>
</ul>
<h2>做法</h2>
<ul>
<li>羊排洗净，葱姜料酒焯水</li>
<li>锅中底油，加葱姜煸炒，加 75g 郫县豆瓣酱+20g 甜面酱煸炒，加香料煸炒，加羊排煸炒，加胡萝卜开水炖熟 （60分钟+）</li>
<li>加白糖 20g，鸡精 3g，耗油 20g，老抽 7g，盐，炖煮 20min</li>
<li>出锅加香菜</li>
</ul>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/10"/><published>2025-06-20T16:07:22+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/9</id><title>汤类</title><updated>2025-07-26T04:43:00.740721+00:00</updated><content type="html"><![CDATA[<h1>参鸡汤</h1>
<ul>
<li>人参, 红枣 , 糯米, 香菇, 枸杞, 姜</li>
<li>净膛小雏鸡, 放入温水焯烫去血水捞出</li>
<li>糯米(泡水), 红枣, 香菇丁, 枸杞混合后填入鸡腹部, 用牙签封口</li>
<li>锅中做开水, 放入鸡, 姜片, 人参, 红枣, 小火煲一小时以上</li>
<li>出锅撒少许盐香葱调味即可</li>
</ul>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/9"/><category term="菜谱"/><published>2025-04-20T04:47:01+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/8</id><title>凉菜类</title><updated>2025-07-26T04:43:00.911963+00:00</updated><content type="html"><![CDATA[<h1>芹菜拌花生</h1>
<h2>主配料</h2>
<ul>
<li>芹菜，胡萝卜，花生米</li>
</ul>
<h2>做法</h2>
<ul>
<li>芹菜切段，</li>
<li>花生米洗净，加水盐生抽白糖，八角花椒桂皮香叶干辣椒（或者五香粉十三香）浸泡 1-10 小时</li>
<li>锅中放入葱姜，放入花生米香料水 ，水开煮至 8 分钟，再焖 5 分钟。</li>
<li>胡萝卜丁和芹菜段焯水断生出锅，和花生拌匀，加花椒油香油盐味精调味装盘（冷藏食用更佳）</li>
</ul>
<h1>擂椒皮蛋</h1>
<ul>
<li>皮蛋 3 个, 二荆条辣椒适量</li>
<li>料汁:
蒜泥, 盐 3 g , 味精 3 g, 白糖 2 g, 适量保宁醋(6g), 适量生抽</li>
<li>二荆条辣椒在铁锅中煸干至表面呈现虎皮状, 撕成条备用</li>
<li>皮蛋, 辣椒捣碎加入料汁, 撒香油装盘</li>
</ul>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/8"/><category term="菜谱"/><published>2025-04-20T03:56:01+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/7</id><title>Python type challenges</title><updated>2025-07-26T04:43:01.088995+00:00</updated><content type="html"><![CDATA[<h2>Python 为什么要需要类型 <a href="https://bernat.tech/posts/the-state-of-type-hints-in-python/">1</a></h2>
<ul>
<li>标注所有参数和返回类型可以更容易理解代码，更易于修改或添加代码</li>
<li>在使用库时，可以更容易地检查类型，方便 IDE 代码补全以及检查错误参数</li>
<li>可以使使用 linter 工具可以提前发现类型错误</li>
<li>运行时数据验证工具，例如：<a href="https://github.com/pydantic/pydantic">pydantic</a></li>
</ul>
<h3>一些有用的资料</h3>
<ul>
<li><a href="https://bernat.tech/posts/the-state-of-type-hints-in-python/">The state of type hints in Python · Tech articles by Bernát Gábor</a></li>
<li><a href="https://github.com/laike9m/Python-Type-Challenges">laike9m/Python-Type-Challenges: Master Python typing (type hints) with interactive online exercises!</a></li>
<li><a href="https://peps.python.org/pep-0484/">PEP 484 – Type Hints | peps.python.org</a></li>
<li><a href="https://bruceyuan.com/post/python-type-challenge-basic.html">Python 类型体操训练（一）-- 基础篇 | 用代码打点酱油的chaofa</a></li>
</ul>
<h2>Python 类型基础</h2>
<h3>常见关键字</h3>
<h4>Union</h4>
<p><code>Union[X, Y]</code> 等价于 <code>X | Y</code> (3.10 及以上)，意味着满足 <code>X</code> 或 <code>Y</code> 之一。
参数必须是某种类型(<code>X</code> 或 <code>Y</code>)，且至少有一个。</p>
<h4>Optional</h4>
<p><code>Optional[X]</code> 等价于 <code>X | None</code> （或 <code>Union[X, None]</code> ） 。</p>
<h4>TypeVar</h4>
<p>可以使用 <code>TypeVar</code> 构造定义它自己的通用容器：</p>
<pre><code class="language-python">T = TypeVar(&#x27;T&#x27;)
class Magic(Generic[T]):
      def __init__(self, value: T) -&gt; None:
         self.value : T = value

 def square_values(vars: Iterable[Magic[int]]) -&gt; None:
     v.value = v.value * v.value
</code></pre>
<p><code>TypeVar</code> 还可以通过指定多个类型参数来创建泛型，表示参数可以是这些类型之一：</p>
<pre><code class="language-python">T = TypeVar(&#x27;T&#x27;, int, str)  # T 可以是 int 或 str

def add(x: T, y: T) -&gt; T:
    return x + y
</code></pre>
<h4>Any</h4>
<p>可以使用 <code>Any</code> 类型可以在不需要的地方禁用类型检查：</p>
<pre><code class="language-python">def foo(item: Any) -&gt; int:
     item.bar()
</code></pre>
<h3>类型别名 (TypeAlias)</h3>
<p>类型别名是使用 <code>type</code> 语句来定义的，它将创建一个 <code>TypeAliasType</code> 的实例。 在这个
示例中，Vector 和 list[float] 将被静态类型检查器等同处理:</p>
<pre><code class="language-python">type Vector = list[float]

def scale(scalar: float, vector: Vector) -&gt; Vector:
    return [scalar * num for num in vector]

# 通过类型检查；浮点数列表是合格的 Vector。
new_vector = scale(2.0, [1.0, -4.2, 5.4])
</code></pre>
<p><code>type</code> 语句是在 Python 3.12 中新增加的。 为了向下兼容，类型别名也可以通过简单的赋
值来创建:</p>
<pre><code class="language-python">Vector = list[float]
</code></pre>
<p>也可以用 TypeAlias 标记来显式说明这是一个类型别名：</p>
<pre><code class="language-python">from typing import TypeAlias

Vector: TypeAlias = list[float]
</code></pre>
<h3>NewType</h3>
<p><code>NewType</code> 用于创建一个新的类型，它与原始类型具有相同的值，但类型检查器会将其视为
不同的类型。</p>
<pre><code class="language-python">from typing import NewType

UserId = NewType(&#x27;UserId&#x27;, int)
some_id = UserId(524313)
</code></pre>
<p>静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误：</p>
<pre><code class="language-python">def get_user_name(user_id: UserId) -&gt; str:
    ...

# 通过类型检查
user_a = get_user_name(UserId(42351))

# 未通过类型检查；整数不能作为 UserId
user_b = get_user_name(-1)
</code></pre>
<blockquote>
<p><strong>备注</strong> 请记住使用类型别名将声明两个类型是相互 等价 的。 使用 type Alias =
Original 将使静态类型检查器在任何情况下都把 Alias 视为与 Original 完全等价。 这
在你想要简化复杂的类型签名时会很有用处。
反之，NewType 声明把一种类型当作另一种类型的 子类型。Derived =
NewType('Derived', Original) 时，静态类型检查器把 Derived 当作 Original 的 子类
，即，Original 类型的值不能用在预期 Derived 类型的位置。这种方式适用于以最小运行
时成本防止逻辑错误。</p>
</blockquote>
<h2>函数</h2>
<h3>可调用对象（Callable）</h3>
<p><code>Callable[[int], str]</code> 表示一个接受 <code>int</code> 类型的单个形参并返回一个 <code>str</code> 的函数。</p>
<pre><code class="language-python">from collections.abc import Callable, Awaitable

def feeder(get_next_item: Callable[[], str]) -&gt; None:
    ...  # 函数体

def async_query(on_success: Callable[[int], None],
                on_error: Callable[[int, Exception], None]) -&gt; None:
    ...  # 函数体

async def on_update(value: str) -&gt; None:
    ...  # 函数体

callback: Callable[[str], Awaitable[None]] = on_update
</code></pre>
<p>如果不确定参数数量，可以使用 <code>Callable[..., ReturnType]</code> 来表示任意数量的参数</p>
<h3>Paramspec</h3>
<p>ParamSpec 是 Python 3.10 引入的，它允许你在类型提示中使用可变数量和类型的参数。
主要用于以下场景:</p>
<ol>
<li>定义高阶函数(接受或返回其他函数的函数)的类型</li>
<li>保留原始函数的参数签名信息</li>
</ol>
<pre><code class="language-python">from typing import Callable, ParamSpec, TypeVar

# Before 3.12 you have to write:
# P = ParamSpec(&#x27;P&#x27;)  # 定义 ParamSpec
# R = TypeVar(&#x27;R&#x27;)  # 定义返回类型的 TypeVar

def add_logging[**P, R](f: Callable[P, R]) -&gt; Callable[P, R]:
    def wrapped(*args: P.args, **kwargs: P.kwargs) -&gt; R:
        print(f&quot;Calling {f.__name__}&quot;)
        return f(*args, **kwargs)
    return wrapped

@add_logging
def greet(name: str) -&gt; str:
    return f&quot;Hello, {name}!&quot;

result = greet(&quot;Alice&quot;)
print(result)
</code></pre>
<h3>Concatenate</h3>
<p>主要用于与 Callable 和 ParamSpec（参数规格）配合使用。它允许我们在类型提示中将多
个参数类型拼接在一起，从而创建更灵活的函数类型提示。</p>
<pre><code class="language-python">from typing import Concatenate, Callable, ParamSpec, TypeVar

P = ParamSpec(&#x27;P&#x27;)  # 定义一个参数规格
T = TypeVar(&#x27;T&#x27;)    # 定义一个泛型类型

def decorator(func: Callable[Concatenate[int, P], T]) -&gt; Callable[P, T]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; T:
        print(&quot;Adding an integer argument&quot;)
        return func(42, *args, **kwargs)  # 在调用原函数时插入一个整数参数
    return wrapper
</code></pre>
<h3>unpack</h3>
<p>Python 3.11 开始引入了类型参数展开（Type Parameter Unpacking），可以通过 * 操作
符解包类型参数。这允许你在类型提示中处理变长的参数列表和泛型参数。</p>
<p>Unpack 也可以与 typing.TypedDict 一起使用以便在函数签名中对 **kwargs 进行类型标
注</p>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

`foo` expects two keyword arguments - `name` of type `str`, and `age` of type `int`.
&quot;&quot;&quot;

from typing import Unpack, TypedDict


class Person(TypedDict):
    name: str
    age: int


def foo(**kwargs: Unpack[Person]):
    ...


## End of your code ##
person: Person = {&quot;name&quot;: &quot;The Meaning of Life&quot;, &quot;age&quot;: 1983}
foo(**person)
foo(**{&quot;name&quot;: &quot;Brian&quot;, &quot;age&quot;: 30})

foo(**{&quot;name&quot;: &quot;Brian&quot;})  # expect-type-error
person2: dict[str, object] = {&quot;name&quot;: &quot;Brian&quot;, &quot;age&quot;: 20}
foo(**person2)  # expect-type-error
foo(**{&quot;name&quot;: &quot;Brian&quot;, &quot;age&quot;: &quot;1979&quot;})  # expect-type-error
</code></pre>
<h3>TypeVarTuple</h3>
<p>TypeVarTuple 可以定义“变长元组”（variadic tuples）类型。这种类型提示可以捕获多个
类型，并且允许元组长度动态变化。它类似于泛型中的 TypeVar，但 TypeVarTuple 是专门
用于处理可变数量的类型参数的。</p>
<p>TypeVarTuple 用于定义一组任意数量的类型参数，它们可以一起表示一个变长的元组或任
意长的参数列表。</p>
<p>TypeVarTuple 定义一个类型元组，它可以代表任意数量的类型。
Unpack 用于从 TypeVarTuple 中提取类型参数，并应用到函数或类中。</p>
<h4>示例</h4>
<p>定义一个函数，它接受一个 Tuple，其中的元素可以是任意类型，并返回这个元组。我们可
以使用 TypeVarTuple 来定义这样一个函数：</p>
<pre><code class="language-python">from typing import TypeVarTuple, Tuple, Unpack

Ts = TypeVarTuple(&#x27;Ts&#x27;)  # 定义一个类型元组 Ts

def my_tuple_func(t: Tuple[Unpack[Ts]]) -&gt; Tuple[Unpack[Ts]]:
    return t

# 我们可以使用这个函数处理不同类型和长度的元组：
print(my_tuple_func((1, &#x27;a&#x27;, 3.14)))  # 输出：(1, &#x27;a&#x27;, 3.14)
print(my_tuple_func((True,)))         # 输出：(True,)
</code></pre>
<p>在这个例子中：</p>
<ul>
<li><code>Ts = TypeVarTuple(&#x27;Ts&#x27;)</code> 定义了一个类型变量 <code>Ts</code>，它可以代表一组类型。</li>
<li><code>my_tuple_func</code> 函数接受一个 Tuple，这个元组的类型是由 <code>Unpack[Ts]</code> 解包的。</li>
<li><code>Tuple[Unpack[Ts]]</code> 表示这个元组可以包含多个类型。</li>
</ul>
<h4>示例 2</h4>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Define an `Array` type that supports element-wise addition of arrays with identical dimensions and types.
&quot;&quot;&quot;

from typing import Generic, TypeVar, TypeVarTuple, assert_type

T = TypeVar(&quot;T&quot;)
Ts = TypeVarTuple(&quot;Ts&quot;)


class Array(Generic[*Ts]):
    def __add__(self, other: &quot;Array[*Ts]&quot;) -&gt; &quot;Array[*Ts]&quot;:
        ...


## End of your code ##
from typing import assert_type

a: Array[float, int] = Array()
b: Array[float, int] = Array()
assert_type(a + b, Array[float, int])

c: Array[float, int, str] = Array()
assert_type(a + c, Array[float, int, str])  # expect-type-error
</code></pre>
<hr />
<pre><code class="language-python">P = ParamSpec(&#x27;P&#x27;)
R = TypeVar(&#x27;R&#x27;)

def add_logging(f: Callable[P, R]) -&gt; Callable[P, R]:
    ...
</code></pre>
<h3>TypeGuard</h3>
<p><code>TypeGuard</code> 是一种类型提示，用于告诉类型检查器某个函数在运行时能够对变量的类型进
行校验和收缩。它通常用于类型推断工具（例如 <code>mypy</code>）来缩小类型范围。</p>
<p>假设我们有一个函数 <code>is_str_list</code>，它接受一个 <code>list</code> 并检查该列表中的所有元素是否都是
字符串。我们希望在通过该检查后，类型检查器能够推断出列表是由字符串组成的。</p>
<pre><code class="language-python">from typing import List, TypeGuard, Union

def is_str_list(values: List[Union[str, int]]) -&gt; TypeGuard[List[str]]:
    return all(isinstance(v, str) for v in values)

# 使用示例
my_list: List[Union[str, int]] = [&quot;a&quot;, &quot;b&quot;, 1]

if is_str_list(my_list):
    # 这里类型检查器会推断 my_list 的类型为 List[str]
    print(&quot;All elements are strings&quot;)
</code></pre>
<p>在这个例子中：</p>
<p><code>is_str_list</code> 是一个自定义类型守卫函数，使用 <code>TypeGuard</code> 来标注返回值。
返回类型 <code>TypeGuard[List[str]]</code> 告诉类型检查器，如果 <code>is_str_list</code> 返回 <code>True</code>，
则传入的 <code>values</code> 类型会被认为是 <code>List[str]</code>。</p>
<p>因此，当我们在 <code>if</code> 语句中调用 <code>is_str_list</code> 后，<code>my_list</code> 的类型会自动缩小到
<code>List[str]</code>，而不再是最初的 <code>List[Union[str, int]]</code>。</p>
<h2>类</h2>
<h3>ClassVar</h3>
<p><code>ClassVar</code> 注解是指，给定属性应当用作类变量，而不应设置在类实例上。用法如下：</p>
<pre><code class="language-python">class Starship:
    stats: ClassVar[dict[str, int]] = {} # 类变量
    damage: int = 10                     # 实例变量
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Class `Foo` has a class variable `bar`, which is an integer.
&quot;&quot;&quot;
from typing import ClassVar


class Foo:
    bar: ClassVar[int]
    &quot;&quot;&quot;Hint: No need to write __init__&quot;&quot;&quot;


## End of your code ##
Foo.bar = 1
Foo.bar = &quot;1&quot;  # expect-type-error
Foo().bar = 1  # expect-type-error
</code></pre>
<h3>Self</h3>
<p>表示当前闭包内的类</p>
<pre><code class="language-python">from typing import Self, reveal_type

class Foo:
    def return_self(self) -&gt; Self:
        ...
        return self

class SubclassOfFoo(Foo): pass

reveal_type(Foo().return_self())  # 揭示的类型为 &quot;Foo&quot;
reveal_type(SubclassOfFoo().return_self())  # 揭示的类型为 &quot;SubclassOfFoo&quot;
</code></pre>
<p>此注解在语法上等价于以下代码，但形式更为简洁：</p>
<pre><code class="language-python">from typing import TypeVar

Self = TypeVar(&quot;Self&quot;, bound=&quot;Foo&quot;)

class Foo:
    def return_self(self: Self) -&gt; Self:
        ...
        return self
</code></pre>
<p>通常来说，如果某些内容返回 <code>self</code>，如上面的示例所示，您应该使用 <code>Self</code> 作为返回
值注解。如果 <code>Foo.return_self</code> 被注解为返回 <code>&quot;Foo&quot;</code>，那么类型检查器将推断从
<code>SubclassOfFoo.return_self</code> 返回的对象是 <code>Foo</code> 类型，而不是 <code>SubclassOfFoo</code>。</p>
<p>challenge:</p>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

`return_self` should return an instance of the same type as the current enclosed class.
&quot;&quot;&quot;

from typing import Self


class Foo:
    def return_self(self) -&gt; Self:
        ...


# Another solution using TypeVar
# from typing import TypeVar
#
# T = TypeVar(&#x27;T&#x27;, bound=&#x27;Foo&#x27;)
#
# class Foo:
#     def return_self(self: T) -&gt; T:
#         ...


## End of your code ##
class SubclassOfFoo(Foo):
    pass


f: Foo = Foo().return_self()
sf: SubclassOfFoo = SubclassOfFoo().return_self()

sf: SubclassOfFoo = Foo().return_self()  # expect-type-error
</code></pre>
<h2>泛型（Generic）</h2>
<h3>TypeVar</h3>
<p><code>TypeVar</code> 可以用来定义一个类型变量，它可以代表任意类型，并且可以在多个地方重用。</p>
<p>泛型函数和类可以通过使用 <code>类型形参语法</code> 来实现参数化:</p>
<pre><code class="language-python">from collections.abc import Sequence

def first[T](l: Sequence[T]) -&gt; T:  # 函数是 TypeVar &quot;T&quot; 泛型
    return l[0]
</code></pre>
<p><code>TypeVar</code> 提供 <code>bound</code> 参数可以约束它只能是某种类型的子类。</p>
<pre><code class="language-python">
from typing import TypeVar

# T 必须是 int 或其子类
T = TypeVar(&#x27;T&#x27;, bound=int)

def double(x: T) -&gt; T:
    return x * 2
</code></pre>
<h3>泛型函数（Generic Functions）</h3>
<pre><code class="language-python">from typing import TypeVar

T = TypeVar(&#x27;T&#x27;)  # 定义一个泛型 T

def identity(x: T) -&gt; T:
    return x

# &gt;= 3.12 推荐写法
def identity[T](x: T) -&gt; T:
    return x
</code></pre>
<h3>泛型类</h3>
<p>在泛型类中，类的属性和方法可以适应不同的数据类型。通过 Generic 类，我们可以将类
声明为泛型类。</p>
<h4>泛型类定义</h4>
<p>例如，我们可以定义一个简单的容器类，它能够存储任意类型的数据：</p>
<pre><code class="language-python">from logging import Logger

# `T` 是类体内部有效的类型
class LoggedVar[T]:
    def __init__(self, value: T, name: str, logger: Logger) -&gt; None:
        self.name = name
        self.logger = logger
        self.value = value

    def set(self, new: T) -&gt; None:
        self.log(&#x27;Set &#x27; + repr(self.value))
        self.value = new

    def get(self) -&gt; T:
        self.log(&#x27;Get &#x27; + repr(self.value))
        return self.value

    def log(self, message: str) -&gt; None:
        self.logger.info(&#x27;%s: %s&#x27;, self.name, message)
</code></pre>
<p>泛型类隐式继承自 <code>Generic</code>。为了与 Python 3.11 及更低版本兼容，也允许显式地从
<code>Generic</code> 继承以表示泛型类：</p>
<pre><code class="language-python">from typing import TypeVar, Generic

T = TypeVar(&#x27;T&#x27;)

class LoggedVar(Generic[T]):
    ...
</code></pre>
<h3>泛型和继承</h3>
<p>在面向对象编程中，泛型类可以与继承结合使用，允许子类继承父类的泛型行为。</p>
<pre><code class="language-python">from typing import Generic, TypeVar

T = TypeVar(&#x27;T&#x27;)

class Animal(Generic[T]):
    def speak(self, sound: T) -&gt; None:
        print(f&quot;The animal says {sound}&quot;)

class Dog(Animal[str]):
    pass

dog = Dog()
dog.speak(&quot;woof&quot;)  # 输出：The animal says woof
</code></pre>
<p>在这个例子中，<code>Animal</code> 是一个泛型类，<code>Dog</code> 继承了 <code>Animal</code>，并将泛型 <code>T</code> 限定为
<code>str</code> 类型。</p>
<h3>overload</h3>
<p><code>@overload</code> 装饰器可以用来声明同一函数的多个版本，每个版本有不同的参数类型和返回值
类型，但在运行时不会实际执行。mypy 会根据参数类型来推断正确的类型签名。</p>
<p>非 <code>@overload</code> 装饰的定义将在运行时使用但应被类型检查器忽略。在运行时，直接调用以
<code>@overload</code> 装饰的函数将引发 NotImplementedError。</p>
<p>challenge:</p>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:
`process` is a function that takes one argument `response`
- When `response` is bytes, `process` returns a string
- When `response` is an integer, `process` returns tuple[int, str]
- When `response` is None, `process` returns None
&quot;&quot;&quot;
from typing import overload


@overload
def process(response: None) -&gt; None:
    ...


@overload
def process(response: int) -&gt; tuple[int, str]:
    ...


@overload
def process(response: bytes) -&gt; str:
    ...


def process(response: int | bytes | None) -&gt; str | None | tuple[int, str]:
    ...


## End of your code ##
from typing import assert_type

assert_type(process(b&quot;42&quot;), str)
assert_type(process(42), tuple[int, str])
assert_type(process(None), None)

assert_type(process(42), str)  # expect-type-error
assert_type(process(None), str)  # expect-type-error
assert_type(process(b&quot;42&quot;), tuple[int, str])  # expect-type-error
assert_type(process(None), tuple[int, str])  # expect-type-error
assert_type(process(42), str)  # expect-type-error
assert_type(process(None), str)  # expect-type-error
</code></pre>
<h3>Protocol</h3>
<p>用于定义“结构化子类型”（structural subtyping），也称为“鸭子类型”。<code>Protocol</code>  允
许我们通过“接口”来定义一个类型，而不强制要求对象必须显式继承这些接口。只要一个对
象实现了所需的方法或属性，它就可以被认为符合某个 <code>Protocol</code>。</p>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:
    Define a protocol for class `SupportsQuack` that supports a &quot;quack&quot; method.
&quot;&quot;&quot;

from typing import Protocol


class SupportsQuack(Protocol):
    def quack(self) -&gt; None:
        ...


## End of your code ##
class Duck:
    def quack(self) -&gt; None:
        print(&quot;quack!&quot;)


class Dog:
    def bark(self) -&gt; None:
        print(&quot;bark!&quot;)


duck: SupportsQuack = Duck()
dog: SupportsQuack = Dog()  # expect-type-error
</code></pre>
<h3>callable-protocol</h3>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Define a callable type that accepts a string parameter called `name` and returns None.
&quot;&quot;&quot;
from typing import Protocol


class SingleStringInput(Protocol):
    def __call__(self, name: str) -&gt; None:
        ...


## End of your code ##
def accept_single_string_input(func: SingleStringInput) -&gt; None:
    func(name=&quot;name&quot;)


def string_name(name: str) -&gt; None:
    ...


def string_value(value: str) -&gt; None:
    ...


def return_string(name: str) -&gt; str:
    return name


accept_single_string_input(string_name)
accept_single_string_input(string_value)  # expect-type-error
accept_single_string_input(return_string)  # expect-type-error
</code></pre>
<h2>TypedDict</h2>
<p>TypedDict 声明一个字典类型，字典定义一个具有特定键和值类型的字典结构，可以像定义
类一样定义字典的键和值的类型，确保字典的键和值符合预期。 可以使用 NotRequired 将
单独的键标记为非必要。</p>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Define a class `Student` that represents a dictionary with three keys:
- name, a string
- age, an integer
- school, a string
&quot;&quot;&quot;
from typing import TypedDict

class Student(TypedDict):
    name: str
    age: int
    school: str

a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}
a: Student = {&quot;name&quot;: 1, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {(1,): &quot;Tom&quot;, &quot;age&quot;: 2, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: &quot;2&quot;, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 2}  # expect-type-error
assert Student(name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;) == dict(
    name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;
)
</code></pre>
<p>默认情况下，所有的键都必须出现在一个 TypedDict 中。可以使用 NotRequired 将单独
的键标记为非必要</p>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Define a class `Student` that represents a dictionary with three keys:
- name, a string
- age, an integer
- school, a string

Note: school can be optional
&quot;&quot;&quot;

from typing import TypedDict, NotRequired

class Student(TypedDict):
    name: str
    age: int
    school: NotRequired[str]

a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 15}
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}
a: Student = {&quot;name&quot;: 1, &quot;age&quot;: 15, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {(1,): &quot;Tom&quot;, &quot;age&quot;: 2, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: &quot;2&quot;, &quot;school&quot;: &quot;Hogwarts&quot;}  # expect-type-error
a: Student = {&quot;z&quot;: &quot;Tom&quot;, &quot;age&quot;: 2}  # expect-type-error
assert Student(name=&quot;Tom&quot;, age=15) == dict(name=&quot;Tom&quot;, age=15)
assert Student(name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;) == dict(
    name=&quot;Tom&quot;, age=15, school=&quot;Hogwarts&quot;
)

</code></pre>
<p>使用 total=False 时，TypedDict 中单独的键可以使用 Required 标记为必要的</p>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Define a class `Person` that represents a dictionary with five string keys:
    name, age, gender, address, email

The value of each key must be the specified type:
    name - str, age - int, gender - str, address - str, email - str

Note: Only `name` is required
&quot;&quot;&quot;

from typing import TypedDict, Required


class Person(TypedDict, total=False):
    name: Required[str]
    age: int
    gender: str
    address: str
    email: str


# Alternative soltion:
#
# Person = TypedDict(&#x27;Person&#x27;, {
#     name: Required[str],
#     age: int,
#     gender: str,
#     address: str,
#     email: str,
# }, total=False):

## End of your code ##
a: Person = {
    &quot;name&quot;: &quot;Capy&quot;,
    &quot;age&quot;: 1,
    &quot;gender&quot;: &quot;Male&quot;,
    &quot;address&quot;: &quot;earth&quot;,
    &quot;email&quot;: &quot;capy@bara.com&quot;,
}
a: Person = {&quot;name&quot;: &quot;Capy&quot;}
a: Person = {&quot;age&quot;: 1, &quot;gender&quot;: &quot;Male&quot;, &quot;address&quot;: &quot;&quot;, &quot;email&quot;: &quot;&quot;} # expect-type-error
</code></pre>
<h2>其他</h2>
<h3>Literal</h3>
<p>特殊类型注解形式，用于定义“字面值类型”。</p>
<p>Literal 可以用来向类型检查器说明被注解的对象具有与所提供的字面量之一相同的值。</p>
<pre><code class="language-python">def validate_simple(data: Any) -&gt; Literal[True]:  # 总是返回 True
    ...

type Mode = Literal[&#x27;r&#x27;, &#x27;rb&#x27;, &#x27;w&#x27;, &#x27;wb&#x27;]
def open_helper(file: str, mode: Mode) -&gt; str:
    ...

open_helper(&#x27;/some/path&#x27;, &#x27;r&#x27;)      # 通过类型检查
open_helper(&#x27;/other/path&#x27;, &#x27;typo&#x27;)  # 类型检查错误
</code></pre>
<h3>LiteralString</h3>
<p>只包括字符串字面值的的特殊类型。</p>
<pre><code class="language-python">def run_query(sql: LiteralString) -&gt; None:
    ...

def caller(arbitrary_string: str, literal_string: LiteralString) -&gt; None:
    run_query(&quot;SELECT * FROM students&quot;)  # 可以
    run_query(literal_string)  # 可以
    run_query(&quot;SELECT * FROM &quot; + literal_string)  # 可以
    run_query(arbitrary_string)  # 类型检查器错误
    run_query(  # 类型检查器错误
        f&quot;SELECT * FROM students WHERE name = {arbitrary_string}&quot;
    )
</code></pre>
<p>LiteralString 对于会因用户可输入任意字符串而导致问题的敏感 API 很有用。例如，上
述两处导致类型检查器报错的代码可能容易被 SQL 注入攻击。</p>
<h3>装饰器（decorator）</h3>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

定义一个装饰器，它包装一个函数并返回一个具有相同签名的函数。
&quot;&quot;&quot;
from typing import Callable, TypeVar

# For Python &lt; 3.12
#
# T = TypeVar(&quot;T&quot;, bound=Callable)
#
# def decorator(func: T) -&gt; T:
#     return func


# For Python &gt;= 3.12
def decorator[T: Callable](func: T) -&gt; T:
    return func


## End of your code ##
@decorator
def foo(a: int, *, b: str) -&gt; None:
    ...


@decorator
def bar(c: int, d: str) -&gt; None:
    ...


foo(1, b=&quot;2&quot;)
bar(c=1, d=&quot;2&quot;)

foo(1, &quot;2&quot;)  # expect-type-error
foo(a=1, e=&quot;2&quot;)  # expect-type-error
decorator(1)  # expect-type-error
</code></pre>
<ul>
<li>TODO:</li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

定义一个装饰器，它包装一个函数并返回一个具有相同签名的函数。
这个装饰器接受一个名为 `message` 的字符串类型参数。
&quot;&quot;&quot;
from collections.abc import Callable
from typing import TypeVar

# For Python &lt; 3.12
#
# T = TypeVar(&quot;T&quot;, bound=Callable)
#
# def decorator(message: str) -&gt; Callable[[T], T]:
#     return func


# For Python &gt;= 3.12
def decorator[T: Callable](message: str) -&gt; Callable[[T], T]:
    ...


## End of your code ##
@decorator(message=&quot;x&quot;)
def foo(a: int, *, b: str) -&gt; None:
    ...


@decorator  # expect-type-error
def bar(a: int, *, b: str) -&gt; None:
    ...


foo(1, b=&quot;2&quot;)
foo(1, &quot;2&quot;)  # expect-type-error
foo(a=1, e=&quot;2&quot;)  # expect-type-error
decorator(1)  # expect-type-error
</code></pre>
<h3>描述器（descriptor）</h3>
<p><code>Self</code> 是一个特殊类型，表示当前闭包内的类。</p>
<pre><code class="language-python">from typing import Self, reveal_type

class Foo:
    def return_self(self) -&gt; Self:
        ...
        return self

class SubclassOfFoo(Foo): pass

reveal_type(Foo().return_self())  # 揭示的类型为 &quot;Foo&quot;
reveal_type(SubclassOfFoo().return_self())  # 揭示的类型为 &quot;SubclassOfFoo&quot;
</code></pre>
<p>此注解在语法上等价于以下代码，但形式更为简洁：</p>
<pre><code class="language-python">from typing import TypeVar

Self = TypeVar(&quot;Self&quot;, bound=&quot;Foo&quot;)

class Foo:
    def return_self(self: Self) -&gt; Self:
        ...
        return self
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Create a descriptor and annotate the __get__ method.
&quot;&quot;&quot;

from typing import Any, Self, overload


class Descriptor:
    # 如果 instance 是 None,表示是通过类访问的，返回描述符自身 (self)
    @overload
    def __get__(self, instance: None, owner: type) -&gt; Self:
        ...

    # 通过实例访问的，返回一个字符串 &quot;描述符值&quot;
    @overload
    def __get__(self, instance: Any, owner: type) -&gt; str:
        ...

    def __get__(self, instance: Any, owner: type) -&gt; Self | str:
        ...


## End of your code ##
class TestClass:
    a = Descriptor()


def descriptor_self(x: Descriptor) -&gt; None:
    ...


def string_value(x: str) -&gt; None:
    ...


descriptor_self(TestClass.a)
string_value(TestClass().a)
descriptor_self(TestClass().a)  # expect-type-error
string_value(TestClass.a)  # expect-type-error
</code></pre>
<h3>生成器（generator）</h3>
<p>生成器可以使用泛型类型 <code>Generator[YieldType, SendType, ReturnType]</code> 来标。 例如:</p>
<pre><code class="language-python">def echo_round() -&gt; Generator[int, float, str]:
    sent = yield 0
    while sent &gt;= 0:
        sent = yield round(sent)
    return &#x27;Done&#x27;
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

`gen` is a generator that yields a integer, and can accept a string sent to it.
It does not return anything.
&quot;&quot;&quot;

from collections.abc import Generator


def gen() -&gt; Generator[int, str, None]:
    &quot;&quot;&quot;You don&#x27;t need to implement it&quot;&quot;&quot;
    ...


## End of your code ##
from typing import assert_type

generator = gen()
assert_type(next(generator), int)
generator.send(&quot;sss&quot;)
generator.send(3)  # expect-type-error
</code></pre>
<h3>never</h3>
<p>Never 和 NoReturn 代表 底类型(Bottom Type)，一种没有成员的类型。
它们可被用于指明一个函数绝不会返回，例如 sys.exit():</p>
<pre><code class="language-python">from typing import Never  # 或 NoReturn

def stop() -&gt; Never:
    raise RuntimeError(&#x27;no way&#x27;)
</code></pre>
<p>或者用于定义一个绝不应被调用的函数，因为不存在有效的参数，例如 assert_never():</p>
<pre><code class="language-python">from typing import Never  # 或 NoReturn

def never_call_me(arg: Never) -&gt; None:
    pass

def int_or_str(arg: int | str) -&gt; None:
    never_call_me(arg)  # 类型检查器错误
    match arg:
        case int():
            print(&quot;It&#x27;s an int&quot;)
        case str():
            print(&quot;It&#x27;s a str&quot;)
        case _:
            never_call_me(arg)  # OK, arg is of type Never (or NoReturn)
</code></pre>
<p>Never 和 NoReturn 在类型系统中具有相同的含义并且静态类型检查器会以相同的方式对待这两者。</p>
<h3>buffer</h3>
<ul>
<li><a href="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects">https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects</a></li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot;
TODO:

Annotate the function `read_buffer`, which accepts anything that is a buffer.

See https://docs.python.org/3.12/reference/datamodel.html#object.__buffer__
&quot;&quot;&quot;

from collections.abc import Buffer


def read_buffer(b: Buffer):
    ...


## End of your code ##

from array import array


class MyBuffer:
    def __init__(self, data: bytes):
        self.data = bytearray(data)
        self.view = None

    def __buffer__(self, flags: int) -&gt; memoryview:
        self.view = memoryview(self.data)
        return self.view


read_buffer(b&quot;foo&quot;)
read_buffer(memoryview(b&quot;foo&quot;))
read_buffer(array(&quot;l&quot;, [1, 2, 3, 4, 5]))
read_buffer(MyBuffer(b&quot;foo&quot;))
read_buffer(&quot;foo&quot;)  # expect-type-error
read_buffer(1)  # expect-type-error
read_buffer([&quot;foo&quot;])  # expect-type-error
</code></pre>
<h2>TODO: 协变，逆变，不变(covariant, contravariant, invariant)</h2>
<h2>排查工具</h2>
<h3>使用 <code>reveal_type</code> 查看推断类型</h3>
<pre><code class="language-python">a = [4]
reveal_type(a)         # -&gt; error: Revealed type is &#x27;builtins.list[builtins.int*]&#x27;
</code></pre>
<h3>使用 <code>cast</code> 来强制指定类型：</h3>
<pre><code class="language-python">from typing import List, cast
a = [4]
b = cast(List[int], a) # passes fine
c = cast(List[str], a) # type: List[str] # passes fine (no runtime check)
reveal_type(c)         # -&gt; error: Revealed type is &#x27;builtins.list[builtins.str]&#x27;
</code></pre>
<h3>使用类型忽略标记禁用一行中的错误：</h3>
<pre><code class="language-python">x = confusing_function() # type: ignore # see mypy/issues/1167
</code></pre>
<h2>生成 type annotation</h2>
<ol>
<li><code>mypy stubgen</code> <a href="https://github.com/python/mypy/blob/master/mypy/stubgen.py">mypy/mypy/stubgen.py at master · python/mypy</a></li>
<li><code>monkeytype</code> <a href="https://github.com/Instagram/MonkeyType">Instagram/MonkeyType: A Python library that generates static type annotations by collecting runtime types</a></li>
</ol>
<h2>一些类型检查工具</h2>
<ol>
<li><a href="https://mypy-lang.org/">mypy - Optional Static Typing for Python</a></li>
<li><a href="https://github.com/microsoft/pyright">microsoft/pyright: Static Type Checker for Python</a></li>
<li><a href="https://github.com/facebook/pyre-check">facebook/pyre-check: Performant type-checking for python.</a></li>
<li><a href="https://github.com/google/pytype">google/pytype: A static type analyzer for Python code</a></li>
</ol>
<hr />
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/7"/><category term="Python"/><published>2024-10-20T07:10:34+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/6</id><title>小吃类</title><updated>2025-07-26T04:43:01.289774+00:00</updated><content type="html"><![CDATA[<h2>烤冷面-赖皮猴版</h2>
<ul>
<li>利民蒜蓉辣酱 80 克，天山红番茄沙司 100 克，白糖 40 克，太太乐鸡粉 10 克，味精 10 克，耗油 6 克，户户辣椒酱 10 克，半颗粒孜然粉 4 克，玉米淀粉 2 克，雪碧 20 克，清水 130 克。在锅中搅拌均匀熬好</li>
<li>葱花香菜洋葱碎适量</li>
<li>锅中适量油，放入冷面，下面刺水加热变软，打鸡蛋，翻面刷酱料，撒葱花香菜洋葱碎，卷好刷酱料撒芝麻出锅，可以适量烹醋</li>
</ul>
<h1>烤串</h1>
<h2>蜜汁梅肉</h2>
<ul>
<li>猪梅花肉</li>
<li>蜂蜜，五香粉少量，海鲜酱油，香料油，红油，腐乳汁，葱姜水，淀粉</li>
</ul>
<h2>羊肉串腌制</h2>
<ul>
<li>洋葱，红油，底味盐，啤酒</li>
</ul>
<h2>酱油生筋</h2>
<ul>
<li>牛生筋，定刀切片，加柠檬汁盐糖豆油腌制后串串（葱油酱烤制），加孜然芝麻辣椒面</li>
</ul>
<h2>烤双筋</h2>
<ul>
<li>牛板筋，牛蹄筋（亮筋），高压锅葱姜盐压熟（20-40 分钟）后串串</li>
<li>刷油烤制（勤翻面），刷冷面酱，孜然芝麻辣椒面</li>
</ul>
<h2>生烤鸡爪</h2>
<ul>
<li>酱：蒜蓉，紫洋葱蓉，红太阳烧烤酱，辣妹子酱，海鲜酱油，香油，鸡汁，水</li>
<li>鸡爪清晰干净劈开串串</li>
<li>水分烤干刷油烤脆，再刷酱，撒芝麻孜然辣椒面</li>
</ul>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/6"/><category term="菜谱"/><published>2024-08-17T13:02:16+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/5</id><title>TODO</title><updated>2025-07-26T04:43:01.487281+00:00</updated><content type="html"><![CDATA[<h1>TODO: blog 优化</h1>
<ul>
<li><input disabled="" type="checkbox"> 配置 MkDocs 作为笔记子目录</li>
<li><input disabled="" type="checkbox"> 支持 issue DRAFT 标签，zola 编译时不渲染文章</li>
<li><input disabled="" type="checkbox"> issue 标签自动嵌入 zola 模板中</li>
<li><input disabled="" type="checkbox"> 优化文件自动备份策略</li>
<li><input disabled="" type="checkbox"> 测试图片嵌入</li>
<li><input disabled="" type="checkbox"> 测试公式</li>
<li><input disabled="" type="checkbox"> 申请域名</li>
<li><input disabled="" type="checkbox"> 配置 CDN 加速</li>
<li><input disabled="" type="checkbox"> 测试 Vercel 部署</li>
</ul>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/5"/><category term="TODO"/><published>2023-11-14T11:33:33+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/4</id><title>鱼虾海鲜河鲜类</title><updated>2025-07-26T04:43:01.652762+00:00</updated><content type="html"><![CDATA[<h1>TODO</h1>
<h2>酱油水煮杂鱼</h2>
<ul>
<li>小杂鱼改斜刀（叶子鱼，梭子鱼，刺中鱼，金线鱼，朱带，黄花，黄刺，银鲳鱼）</li>
<li>姜切丝，蒜，豆豉，小米辣切碎。萝卜干泡水切丁</li>
<li>糖，生抽，老抽，蚝油，花雕酒，水，葱油白胡椒调碗汁备用</li>
<li>锅烧热放底油，放入姜蒜豆豉小米椒，放入萝卜干，鱼（注意不需要煎鱼），倒入碗汁，小火煮制 5 分钟，出锅放葱段，葱油</li>
</ul>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/4"/><category term="菜谱"/><published>2023-10-29T14:43:46+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/3</id><title>蔬菜类</title><updated>2025-07-26T04:43:01.829790+00:00</updated><content type="html"><![CDATA[<h1>果仁菠菜</h1>
<ul>
<li>菠菜用刀拍，撕成丝，切2寸长。</li>
<li>下锅烫菠菜梗，开锅放菠菜叶，叶绿捞出。</li>
<li>料汁：拍蒜，熟花生，盐，海鲜酱油，少点醋，辣椒油，少点糖。</li>
<li>菠菜放凉，拧干水分再放料汁</li>
</ul>
<h1>土豆茄子酱（东北厨子大鹏做法）</h1>
<ul>
<li>土豆改刀切小块，茄子撕成条。</li>
<li>锅中加豆油，猪肉碎煸炒（可选），加入茄子煸软乘出备用。</li>
<li>锅中留底油，加入葱姜片煸炒。小火加入花椒面，酱油，香其酱煸炒。放入清水，加入茄子和土豆。根据汤的咸淡看是否需要补盐</li>
<li>茄子土豆炖熟后捣成酱，注意锅中要留一些汤。快出锅时加入葱花，青椒碎，蒜沫，香菜沫</li>
</ul>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/3"/><category term="菜谱"/><published>2023-10-29T14:42:19+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/2</id><title>猪肉类</title><updated>2025-07-26T04:43:01.992518+00:00</updated><content type="html"><![CDATA[<h1>农家一碗香（村驴）</h1>
<ul>
<li>
主配料<ul>
<li>鸡蛋，猪肉，螺丝椒</li>
<li>豆豉，葱姜蒜，小米辣</li>
</ul>
</li>
<li>锅中适量油，放入鸡蛋 3-4 个（不打散）煎熟，捣成大块盛出备用</li>
<li>辣椒切滚刀块锅中煸炒盛出备用</li>
<li>锅中适量油，放入五花肉煸炒，放入豆豉，葱姜蒜，小米辣，螺丝椒煸炒</li>
<li>加入生抽，老抽，耗油，糖，鸡精，鸡蛋翻炒均匀出锅</li>
</ul>
<h1>肉沫茄子（村驴）</h1>
<ul>
<li>
主配料<ul>
<li>蒜沫，葱花， 香菜沫，姜丝</li>
<li>茄子，猪肉糜，青红辣椒圈</li>
</ul>
</li>
<li>锅中底油，茄子切段放入锅中焖煎（4-5 分钟）</li>
<li>锅留底油，煸炒肉糜肉酥吐油，放入黄豆酱姜丝煸炒，烹料酒，老抽生抽热水，加入鸡精，盐，糖，耗油，焖 8 分钟</li>
<li>放入青红辣椒，再焖 1 分钟，勾芡后放入葱花蒜沫香菜沫出锅</li>
</ul>
<h1>脆皮五花肉</h1>
<ul>
<li>盐4，五香粉3，孜然粉3 黄酒腌肉</li>
<li>脆皮水：
水 50g，盐 4g，小苏打 3g，面碱 4g</li>
<li>肉穿刺，刷白醋，脆皮水两遍，隔夜风干</li>
<li>表面抹白醋，粗盐，160度 50 分钟，230度 15 分钟</li>
</ul>
<h1>卤肉饭（赖皮猴版）</h1>
<ul>
<li>五花肉
猪棒骨
清水12斤
姜片60克
葱段60克
香叶两片
桂皮6克
良姜7.5克
草果3克
拍破祛仔
丁香3粒
白寇一克
八角1.5克
花椒1克
小茴香一克
盐30克
煮一个小时，切成 1.5cm 宽小长方条备用</li>
<li>红葱头80克切丝,蒜片20克，干虾米 15g，锅中100g油炸香，炸成焦糖色，</li>
<li>黄冰糖60克，酱油160克，绍兴酒100克，开大火熬化至起小泡。放入猪肉，耗油30克，虾米葱蒜酥，放入卤肉汤，中小火煮30分钟</li>
</ul>
<h1>卤肉饭（詹姆士）</h1>
<p>材料：蒜头6颗、红葱头6颗、葱2根、猪五花肉丝1公斤、黑糖1匙、蚝油2匙、酱油</p>
<p>1.五花肉切条倒入锅内，将猪油煸炒出来</p>
<p>2.外表呈现熟的状态下，先加入红葱头煸炒出香味，然后再倒入蒜、葱、及1匙黑糖</p>
<p>3.锅内加入2匙蚝油、少许酱油后，拌炒出酱香味</p>
<p>4.加入米酒后，倒入水淹至猪肉表面</p>
<p>5.撒入白胡椒粉，盖锅熬煮25分钟，完成</p>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/2"/><category term="菜谱"/><published>2023-09-21T15:39:39+00:00</published></entry><entry><id>https://github.com/shiyang07ca/shiyang07ca.github.io/issues/1</id><title>Fisrt Blog</title><updated>2025-07-26T04:43:02.196125+00:00</updated><content type="html"><![CDATA[<p>Test update </p>
<h1>Test Style</h1>
<h2>Layer</h2>
<h1>Second</h1>
<h2>Test config update</h2>
]]></content><link href="https://github.com/shiyang07ca/shiyang07ca.github.io/issues/1"/><category term="test"/><published>2023-05-22T05:40:21+00:00</published></entry></feed>