<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
	<title>Shiyang&#x27;s Blog</title>
	<subtitle>Cheese is power</subtitle>
	<link href="https://shiyang07ca.github.io/feed.xml" rel="self" type="application/atom+xml"/>
    <link href="https://shiyang07ca.github.io"/>
	<updated>2026-02-01T00:00:00+00:00</updated>
	<id>https://shiyang07ca.github.io/feed.xml</id>
	<entry xml:lang="zh-CN">
		<title>烧烤</title>
		<published>2026-01-25T00:00:00+00:00</published>
		<updated>2026-02-01T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0011-shao-kao/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0011-shao-kao/</id>
		<content type="html">&lt;h1 id=&quot;shao-kao&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;11&quot;&gt;烧烤&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#shao-kao&quot; aria-label=&quot;Anchor link for: shao-kao&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;yang-rou-chuan&quot;&gt;羊肉串&lt;a class=&quot;zola-anchor&quot; href=&quot;#yang-rou-chuan&quot; aria-label=&quot;Anchor link for: yang-rou-chuan&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主料：羊排肉、羊腿肉、羊上脑&lt;&#x2F;li&gt;
&lt;li&gt;腌料：洋葱，盐，蛋清，啤酒，红油&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;mi-zhi-mei-rou&quot;&gt;蜜汁梅肉&lt;a class=&quot;zola-anchor&quot; href=&quot;#mi-zhi-mei-rou&quot; aria-label=&quot;Anchor link for: mi-zhi-mei-rou&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主料：猪梅花肉&lt;&#x2F;li&gt;
&lt;li&gt;腌料：蜂蜜，五香粉，海鲜酱油，调料油，红油，腐乳汁，葱姜水，玉米淀粉（少量），啤酒&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;kao-niu-le-tiao-jia-ting-ban-rou&quot;&gt;烤牛肋条&amp;amp;家庭拌肉&lt;a class=&quot;zola-anchor&quot; href=&quot;#kao-niu-le-tiao-jia-ting-ban-rou&quot; aria-label=&quot;Anchor link for: kao-niu-le-tiao-jia-ting-ban-rou&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主料：牛肋条去筋膜切薄片&lt;&#x2F;li&gt;
&lt;li&gt;配料：洋葱香菜，耗油鸡精味精，芝麻孜然辣椒片，啤酒，全蛋，豆油，白糖&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;jiang-you-sheng-jin&quot;&gt;酱油生筋&lt;a class=&quot;zola-anchor&quot; href=&quot;#jiang-you-sheng-jin&quot; aria-label=&quot;Anchor link for: jiang-you-sheng-jin&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主料：牛上脑？&lt;&#x2F;li&gt;
&lt;li&gt;切薄片，加柠檬汁，少量盐，糖，豆油&lt;&#x2F;li&gt;
&lt;li&gt;大火，刷油，刷葱油酱油，孜然芝麻辣椒面&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;niu-ban-jin-liang-jin&quot;&gt;牛板筋&amp;amp;亮筋&lt;a class=&quot;zola-anchor&quot; href=&quot;#niu-ban-jin-liang-jin&quot; aria-label=&quot;Anchor link for: niu-ban-jin-liang-jin&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主料：牛板筋，牛亮筋。高压锅加盐压制成熟&lt;&#x2F;li&gt;
&lt;li&gt;板筋中火，刷油，刷酱（烤冷面酱），孜然芝麻辣椒面&lt;&#x2F;li&gt;
&lt;li&gt;亮筋大火烤，刷油，刷酱，孜然芝麻辣椒面&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;ji-zhua&quot;&gt;鸡爪&lt;a class=&quot;zola-anchor&quot; href=&quot;#ji-zhua&quot; aria-label=&quot;Anchor link for: ji-zhua&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;鸡爪切开，骨头敲碎，按扁&lt;&#x2F;li&gt;
&lt;li&gt;蒜蓉，洋葱蓉，红太阳烧烤酱，辣椒酱，海鲜酱油，香油，鸡汁，水&lt;&#x2F;li&gt;
&lt;li&gt;中火烤干，变色后刷油，烤干后刷酱，撒孜然芝麻辣椒面&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>主食类</title>
		<published>2026-01-25T00:00:00+00:00</published>
		<updated>2026-01-25T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0012-zhu-shi-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0012-zhu-shi-lei/</id>
		<content type="html">&lt;h1 id=&quot;zhu-shi-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;12&quot;&gt;主食类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhu-shi-lei&quot; aria-label=&quot;Anchor link for: zhu-shi-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;shi-you-wang-chao-mian&quot;&gt;豉油王炒面&lt;a class=&quot;zola-anchor&quot; href=&quot;#shi-you-wang-chao-mian&quot; aria-label=&quot;Anchor link for: shi-you-wang-chao-mian&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主料：炒面300g&lt;&#x2F;li&gt;
&lt;li&gt;辅料：肥仔芽菜&#x2F;银芽300g，鸡汤100g，韭菜花60g，韭王60g 蒜苗，小米辣&lt;&#x2F;li&gt;
&lt;li&gt;调料：豉油&#x2F;生抽&#x2F;美极15g，草菇老抽20g，辣鲜露15g&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;bu-zou&quot;&gt;步骤&lt;a class=&quot;zola-anchor&quot; href=&quot;#bu-zou&quot; aria-label=&quot;Anchor link for: bu-zou&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;锅中加水，油，面条焯水2分钟盛出，放入豉油拌匀&lt;&#x2F;li&gt;
&lt;li&gt;豆芽韭王蒜苗煸炒半熟&lt;&#x2F;li&gt;
&lt;li&gt;中小火，下面条加鸡汤，小火煎香，加配菜炒匀出锅&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;zhao-xian-men-fan-qie-zi&quot;&gt;朝鲜焖饭茄子&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhao-xian-men-fan-qie-zi&quot; aria-label=&quot;Anchor link for: zhao-xian-men-fan-qie-zi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;bu-zou-1&quot;&gt;步骤&lt;a class=&quot;zola-anchor&quot; href=&quot;#bu-zou-1&quot; aria-label=&quot;Anchor link for: bu-zou-1&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;大葱切碎，茄子细条备用&lt;&#x2F;li&gt;
&lt;li&gt;锅中烧热加猪油，放入葱花茄子煸炒，放入生抽，黑胡椒，牛肉粉（十三香五香粉也行），盐&lt;&#x2F;li&gt;
&lt;li&gt;米饭加水焖 10 分钟后，放入茄子&lt;&#x2F;li&gt;
&lt;li&gt;拌饭酱：小米辣蒜末葱花芝麻辣椒面，po泼热油，放入生抽白糖&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>牛羊肉类</title>
		<published>2025-06-20T00:00:00+00:00</published>
		<updated>2025-11-08T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0010-niu-yang-rou-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0010-niu-yang-rou-lei/</id>
		<content type="html">&lt;h1 id=&quot;niu-yang-rou-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;10&quot;&gt;牛羊肉类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#niu-yang-rou-lei&quot; aria-label=&quot;Anchor link for: niu-yang-rou-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h1 id=&quot;jin-tou-ba-nao&quot;&gt;筋头巴脑&lt;a class=&quot;zola-anchor&quot; href=&quot;#jin-tou-ba-nao&quot; aria-label=&quot;Anchor link for: jin-tou-ba-nao&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;zhu-pei-liao&quot;&gt;主配料&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhu-pei-liao&quot; aria-label=&quot;Anchor link for: zhu-pei-liao&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;筋头巴脑&lt;&#x2F;li&gt;
&lt;li&gt;小料：葱 20g，姜 15g，大蒜 20g， 香叶 3 片，八角 2g，草果皮 1 个，桂皮 1 g，白芷 2 g，干辣椒适量&lt;&#x2F;li&gt;
&lt;li&gt;酱料：郫县豆瓣酱1勺，黄豆酱 1 勺，番茄膏 2 勺&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;zuo-fa&quot;&gt;做法&lt;a class=&quot;zola-anchor&quot; href=&quot;#zuo-fa&quot; aria-label=&quot;Anchor link for: zuo-fa&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;牛肉切小块，加水，葱姜花椒白酒焯水去腥&lt;&#x2F;li&gt;
&lt;li&gt;锅中加油，先下葱姜蒜煸炒，再加入酱料煸炒，酱料炒透加入牛肉煸炒，烹黄酒，生抽。加水，耗油鸡精冰糖胡椒粉，炖煮 1 小时。汤汁收至粘稠，出锅加香菜&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;hong-shao-niu-wo-gu&quot;&gt;红烧牛窝骨&lt;a class=&quot;zola-anchor&quot; href=&quot;#hong-shao-niu-wo-gu&quot; aria-label=&quot;Anchor link for: hong-shao-niu-wo-gu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;zhu-pei-liao-1&quot;&gt;主配料&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhu-pei-liao-1&quot; aria-label=&quot;Anchor link for: zhu-pei-liao-1&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;牛窝骨，胡萝卜&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;zuo-fa-1&quot;&gt;做法&lt;a class=&quot;zola-anchor&quot; href=&quot;#zuo-fa-1&quot; aria-label=&quot;Anchor link for: zuo-fa-1&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;牛窝骨焯水去浮沫，加葱姜料酒大料炖熟改刀切小块&lt;&#x2F;li&gt;
&lt;li&gt;锅中加油，加葱姜大料甜面酱煸炒，加酱油牛窝骨煸炒&lt;&#x2F;li&gt;
&lt;li&gt;加牛肉原汤，盐味精糖，牛窝骨胡萝卜炖 25 分钟&lt;&#x2F;li&gt;
&lt;li&gt;加水淀粉勾芡，加花椒油出锅&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;hong-men-yang-pai-cun-lu&quot;&gt;红焖羊排（村驴）&lt;a class=&quot;zola-anchor&quot; href=&quot;#hong-men-yang-pai-cun-lu&quot; aria-label=&quot;Anchor link for: hong-men-yang-pai-cun-lu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;zhu-pei-liao-2&quot;&gt;主配料&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhu-pei-liao-2&quot; aria-label=&quot;Anchor link for: zhu-pei-liao-2&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;羊排，胡萝卜&lt;&#x2F;li&gt;
&lt;li&gt;香料：桂皮 2g，香叶 3 片，草果皮 1 个，良姜 2g，白蔻 3 个，白芷 5g，毛砂仁 3g，丁香 3 粒，白胡椒粒 3g，花椒粒 3g，甘草 2 粒，孜然粒 10g，干辣椒 10g&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;zuo-fa-2&quot;&gt;做法&lt;a class=&quot;zola-anchor&quot; href=&quot;#zuo-fa-2&quot; aria-label=&quot;Anchor link for: zuo-fa-2&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;羊排洗净，葱姜料酒焯水&lt;&#x2F;li&gt;
&lt;li&gt;锅中底油，加葱姜煸炒，加 75g 郫县豆瓣酱+20g 甜面酱煸炒，加香料煸炒，加羊排煸炒，加胡萝卜开水炖熟 （60分钟+）&lt;&#x2F;li&gt;
&lt;li&gt;加白糖 20g，鸡精 3g，耗油 20g，老抽 7g，盐，炖煮 20min&lt;&#x2F;li&gt;
&lt;li&gt;出锅加香菜&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>凉菜类</title>
		<published>2025-04-20T00:00:00+00:00</published>
		<updated>2025-06-21T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0008-liang-cai-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0008-liang-cai-lei/</id>
		<content type="html">&lt;h1 id=&quot;liang-cai-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;8&quot;&gt;凉菜类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#liang-cai-lei&quot; aria-label=&quot;Anchor link for: liang-cai-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h1 id=&quot;qin-cai-ban-hua-sheng&quot;&gt;芹菜拌花生&lt;a class=&quot;zola-anchor&quot; href=&quot;#qin-cai-ban-hua-sheng&quot; aria-label=&quot;Anchor link for: qin-cai-ban-hua-sheng&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;zhu-pei-liao&quot;&gt;主配料&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhu-pei-liao&quot; aria-label=&quot;Anchor link for: zhu-pei-liao&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;芹菜，胡萝卜，花生米&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;zuo-fa&quot;&gt;做法&lt;a class=&quot;zola-anchor&quot; href=&quot;#zuo-fa&quot; aria-label=&quot;Anchor link for: zuo-fa&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;芹菜切段，&lt;&#x2F;li&gt;
&lt;li&gt;花生米洗净，加水盐生抽白糖，八角花椒桂皮香叶干辣椒（或者五香粉十三香）浸泡 1-10 小时&lt;&#x2F;li&gt;
&lt;li&gt;锅中放入葱姜，放入花生米香料水 ，水开煮至 8 分钟，再焖 5 分钟。&lt;&#x2F;li&gt;
&lt;li&gt;胡萝卜丁和芹菜段焯水断生出锅，和花生拌匀，加花椒油香油盐味精调味装盘（冷藏食用更佳）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;lei-jiao-pi-dan&quot;&gt;擂椒皮蛋&lt;a class=&quot;zola-anchor&quot; href=&quot;#lei-jiao-pi-dan&quot; aria-label=&quot;Anchor link for: lei-jiao-pi-dan&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;皮蛋 3 个, 二荆条辣椒适量&lt;&#x2F;li&gt;
&lt;li&gt;料汁:
蒜泥, 盐 3 g , 味精 3 g, 白糖 2 g, 适量保宁醋(6g), 适量生抽&lt;&#x2F;li&gt;
&lt;li&gt;二荆条辣椒在铁锅中煸干至表面呈现虎皮状, 撕成条备用&lt;&#x2F;li&gt;
&lt;li&gt;皮蛋, 辣椒捣碎加入料汁, 撒香油装盘&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>汤类</title>
		<published>2025-04-20T00:00:00+00:00</published>
		<updated>2026-01-25T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0009-tang-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0009-tang-lei/</id>
		<content type="html">&lt;h1 id=&quot;tang-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;9&quot;&gt;汤类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tang-lei&quot; aria-label=&quot;Anchor link for: tang-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;can-ji-tang&quot;&gt;参鸡汤&lt;a class=&quot;zola-anchor&quot; href=&quot;#can-ji-tang&quot; aria-label=&quot;Anchor link for: can-ji-tang&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;人参, 红枣 , 糯米, 香菇, 枸杞, 姜&lt;&#x2F;li&gt;
&lt;li&gt;净膛小雏鸡, 放入温水焯烫去血水捞出&lt;&#x2F;li&gt;
&lt;li&gt;糯米(泡水), 红枣, 香菇丁, 枸杞混合后填入鸡腹部, 用牙签封口&lt;&#x2F;li&gt;
&lt;li&gt;锅中做开水, 放入鸡, 姜片, 人参, 红枣, 小火煲一小时以上&lt;&#x2F;li&gt;
&lt;li&gt;出锅撒少许盐香葱调味即可&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;rou-bing-pi-dan-tang&quot;&gt;肉饼皮蛋汤&lt;a class=&quot;zola-anchor&quot; href=&quot;#rou-bing-pi-dan-tang&quot; aria-label=&quot;Anchor link for: rou-bing-pi-dan-tang&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;肉糜切碎，加马蹄丁（藕、梨均可），皮蛋丁。加蛋清，姜末，葱姜水，胡椒粉，盐，味精，生粉拌匀。&lt;&#x2F;li&gt;
&lt;li&gt;大火上汽，碗底抹猪油，加肉糜蒸 5 分钟定型后，加水，盐味精，蒸 20-30 分钟后，出锅撒葱花&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>Python type challenges</title>
		<published>2024-10-20T00:00:00+00:00</published>
		<updated>2024-10-20T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0007-python-type-challenges/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0007-python-type-challenges/</id>
		<content type="html">&lt;h1 id=&quot;python-type-challenges&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;7&quot;&gt;Python type challenges&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#python-type-challenges&quot; aria-label=&quot;Anchor link for: python-type-challenges&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;python-wei-shen-me-yao-xu-yao-lei-xing-1&quot;&gt;Python 为什么要需要类型 &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;bernat.tech&#x2F;posts&#x2F;the-state-of-type-hints-in-python&#x2F;&quot;&gt;1&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#python-wei-shen-me-yao-xu-yao-lei-xing-1&quot; aria-label=&quot;Anchor link for: python-wei-shen-me-yao-xu-yao-lei-xing-1&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;标注所有参数和返回类型可以更容易理解代码，更易于修改或添加代码&lt;&#x2F;li&gt;
&lt;li&gt;在使用库时，可以更容易地检查类型，方便 IDE 代码补全以及检查错误参数&lt;&#x2F;li&gt;
&lt;li&gt;可以使使用 linter 工具可以提前发现类型错误&lt;&#x2F;li&gt;
&lt;li&gt;运行时数据验证工具，例如：&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;pydantic&quot;&gt;pydantic&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;yi-xie-you-yong-de-zi-liao&quot;&gt;一些有用的资料&lt;a class=&quot;zola-anchor&quot; href=&quot;#yi-xie-you-yong-de-zi-liao&quot; aria-label=&quot;Anchor link for: yi-xie-you-yong-de-zi-liao&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;bernat.tech&#x2F;posts&#x2F;the-state-of-type-hints-in-python&#x2F;&quot;&gt;The state of type hints in Python · Tech articles by Bernát Gábor&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;laike9m&#x2F;Python-Type-Challenges&quot;&gt;laike9m&#x2F;Python-Type-Challenges: Master Python typing (type hints) with interactive online exercises!&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0484&#x2F;&quot;&gt;PEP 484 – Type Hints | peps.python.org&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;bruceyuan.com&#x2F;post&#x2F;python-type-challenge-basic.html&quot;&gt;Python 类型体操训练（一）– 基础篇 | 用代码打点酱油的chaofa&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;python-lei-xing-ji-chu&quot;&gt;Python 类型基础&lt;a class=&quot;zola-anchor&quot; href=&quot;#python-lei-xing-ji-chu&quot; aria-label=&quot;Anchor link for: python-lei-xing-ji-chu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;chang-jian-guan-jian-zi&quot;&gt;常见关键字&lt;a class=&quot;zola-anchor&quot; href=&quot;#chang-jian-guan-jian-zi&quot; aria-label=&quot;Anchor link for: chang-jian-guan-jian-zi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;union&quot;&gt;Union&lt;a class=&quot;zola-anchor&quot; href=&quot;#union&quot; aria-label=&quot;Anchor link for: union&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;Union[X, Y]&lt;&#x2F;code&gt; 等价于 &lt;code&gt;X | Y&lt;&#x2F;code&gt; (3.10 及以上)，意味着满足 &lt;code&gt;X&lt;&#x2F;code&gt; 或 &lt;code&gt;Y&lt;&#x2F;code&gt; 之一。
参数必须是某种类型(&lt;code&gt;X&lt;&#x2F;code&gt; 或 &lt;code&gt;Y&lt;&#x2F;code&gt;)，且至少有一个。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;optional&quot;&gt;Optional&lt;a class=&quot;zola-anchor&quot; href=&quot;#optional&quot; aria-label=&quot;Anchor link for: optional&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;Optional[X]&lt;&#x2F;code&gt; 等价于 &lt;code&gt;X | None&lt;&#x2F;code&gt; （或 &lt;code&gt;Union[X, None]&lt;&#x2F;code&gt; ） 。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;typevar&quot;&gt;TypeVar&lt;a class=&quot;zola-anchor&quot; href=&quot;#typevar&quot; aria-label=&quot;Anchor link for: typevar&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;可以使用 &lt;code&gt;TypeVar&lt;&#x2F;code&gt; 构造定义它自己的通用容器：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;T = TypeVar(&amp;#x27;T&amp;#x27;)
class Magic(Generic[T]):
      def __init__(self, value: T) -&amp;gt; None:
         self.value : T = value

 def square_values(vars: Iterable[Magic[int]]) -&amp;gt; None:
     v.value = v.value * v.value
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;TypeVar&lt;&#x2F;code&gt; 还可以通过指定多个类型参数来创建泛型，表示参数可以是这些类型之一：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;T = TypeVar(&amp;#x27;T&amp;#x27;, int, str)  # T 可以是 int 或 str

def add(x: T, y: T) -&amp;gt; T:
    return x + y
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;any&quot;&gt;Any&lt;a class=&quot;zola-anchor&quot; href=&quot;#any&quot; aria-label=&quot;Anchor link for: any&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;可以使用 &lt;code&gt;Any&lt;&#x2F;code&gt; 类型可以在不需要的地方禁用类型检查：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def foo(item: Any) -&amp;gt; int:
     item.bar()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;lei-xing-bie-ming-typealias&quot;&gt;类型别名 (TypeAlias)&lt;a class=&quot;zola-anchor&quot; href=&quot;#lei-xing-bie-ming-typealias&quot; aria-label=&quot;Anchor link for: lei-xing-bie-ming-typealias&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;类型别名是使用 &lt;code&gt;type&lt;&#x2F;code&gt; 语句来定义的，它将创建一个 &lt;code&gt;TypeAliasType&lt;&#x2F;code&gt; 的实例。 在这个
示例中，Vector 和 list[float] 将被静态类型检查器等同处理:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;type Vector = list[float]

def scale(scalar: float, vector: Vector) -&amp;gt; Vector:
    return [scalar * num for num in vector]

# 通过类型检查；浮点数列表是合格的 Vector。
new_vector = scale(2.0, [1.0, -4.2, 5.4])
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;type&lt;&#x2F;code&gt; 语句是在 Python 3.12 中新增加的。 为了向下兼容，类型别名也可以通过简单的赋
值来创建:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;Vector = list[float]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也可以用 TypeAlias 标记来显式说明这是一个类型别名：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import TypeAlias

Vector: TypeAlias = list[float]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;newtype&quot;&gt;NewType&lt;a class=&quot;zola-anchor&quot; href=&quot;#newtype&quot; aria-label=&quot;Anchor link for: newtype&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;NewType&lt;&#x2F;code&gt; 用于创建一个新的类型，它与原始类型具有相同的值，但类型检查器会将其视为
不同的类型。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import NewType

UserId = NewType(&amp;#x27;UserId&amp;#x27;, int)
some_id = UserId(524313)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def get_user_name(user_id: UserId) -&amp;gt; str:
    ...

# 通过类型检查
user_a = get_user_name(UserId(42351))

# 未通过类型检查；整数不能作为 UserId
user_b = get_user_name(-1)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;&#x2F;strong&gt; 请记住使用类型别名将声明两个类型是相互 等价 的。 使用 type Alias =
Original 将使静态类型检查器在任何情况下都把 Alias 视为与 Original 完全等价。 这
在你想要简化复杂的类型签名时会很有用处。
反之，NewType 声明把一种类型当作另一种类型的 子类型。Derived =
NewType(‘Derived’, Original) 时，静态类型检查器把 Derived 当作 Original 的 子类
，即，Original 类型的值不能用在预期 Derived 类型的位置。这种方式适用于以最小运行
时成本防止逻辑错误。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;han-shu&quot;&gt;函数&lt;a class=&quot;zola-anchor&quot; href=&quot;#han-shu&quot; aria-label=&quot;Anchor link for: han-shu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;ke-diao-yong-dui-xiang-callable&quot;&gt;可调用对象（Callable）&lt;a class=&quot;zola-anchor&quot; href=&quot;#ke-diao-yong-dui-xiang-callable&quot; aria-label=&quot;Anchor link for: ke-diao-yong-dui-xiang-callable&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Callable[[int], str]&lt;&#x2F;code&gt; 表示一个接受 &lt;code&gt;int&lt;&#x2F;code&gt; 类型的单个形参并返回一个 &lt;code&gt;str&lt;&#x2F;code&gt; 的函数。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from collections.abc import Callable, Awaitable

def feeder(get_next_item: Callable[[], str]) -&amp;gt; None:
    ...  # 函数体

def async_query(on_success: Callable[[int], None],
                on_error: Callable[[int, Exception], None]) -&amp;gt; None:
    ...  # 函数体

async def on_update(value: str) -&amp;gt; None:
    ...  # 函数体

callback: Callable[[str], Awaitable[None]] = on_update
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果不确定参数数量，可以使用 &lt;code&gt;Callable[..., ReturnType]&lt;&#x2F;code&gt; 来表示任意数量的参数&lt;&#x2F;p&gt;
&lt;h3 id=&quot;paramspec&quot;&gt;Paramspec&lt;a class=&quot;zola-anchor&quot; href=&quot;#paramspec&quot; aria-label=&quot;Anchor link for: paramspec&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;ParamSpec 是 Python 3.10 引入的，它允许你在类型提示中使用可变数量和类型的参数。
主要用于以下场景:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;定义高阶函数(接受或返回其他函数的函数)的类型&lt;&#x2F;li&gt;
&lt;li&gt;保留原始函数的参数签名信息&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import Callable, ParamSpec, TypeVar

# Before 3.12 you have to write:
# P = ParamSpec(&amp;#x27;P&amp;#x27;)  # 定义 ParamSpec
# R = TypeVar(&amp;#x27;R&amp;#x27;)  # 定义返回类型的 TypeVar

def add_logging[**P, R](f: Callable[P, R]) -&amp;gt; Callable[P, R]:
    def wrapped(*args: P.args, **kwargs: P.kwargs) -&amp;gt; R:
        print(f&amp;quot;Calling {f.__name__}&amp;quot;)
        return f(*args, **kwargs)
    return wrapped

@add_logging
def greet(name: str) -&amp;gt; str:
    return f&amp;quot;Hello, {name}!&amp;quot;

result = greet(&amp;quot;Alice&amp;quot;)
print(result)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;concatenate&quot;&gt;Concatenate&lt;a class=&quot;zola-anchor&quot; href=&quot;#concatenate&quot; aria-label=&quot;Anchor link for: concatenate&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;主要用于与 Callable 和 ParamSpec（参数规格）配合使用。它允许我们在类型提示中将多
个参数类型拼接在一起，从而创建更灵活的函数类型提示。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import Concatenate, Callable, ParamSpec, TypeVar

P = ParamSpec(&amp;#x27;P&amp;#x27;)  # 定义一个参数规格
T = TypeVar(&amp;#x27;T&amp;#x27;)    # 定义一个泛型类型

def decorator(func: Callable[Concatenate[int, P], T]) -&amp;gt; Callable[P, T]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -&amp;gt; T:
        print(&amp;quot;Adding an integer argument&amp;quot;)
        return func(42, *args, **kwargs)  # 在调用原函数时插入一个整数参数
    return wrapper
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;unpack&quot;&gt;unpack&lt;a class=&quot;zola-anchor&quot; href=&quot;#unpack&quot; aria-label=&quot;Anchor link for: unpack&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;Python 3.11 开始引入了类型参数展开（Type Parameter Unpacking），可以通过 * 操作
符解包类型参数。这允许你在类型提示中处理变长的参数列表和泛型参数。&lt;&#x2F;p&gt;
&lt;p&gt;Unpack 也可以与 typing.TypedDict 一起使用以便在函数签名中对 **kwargs 进行类型标
注&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

`foo` expects two keyword arguments - `name` of type `str`, and `age` of type `int`.
&amp;quot;&amp;quot;&amp;quot;

from typing import Unpack, TypedDict


class Person(TypedDict):
    name: str
    age: int


def foo(**kwargs: Unpack[Person]):
    ...


## End of your code ##
person: Person = {&amp;quot;name&amp;quot;: &amp;quot;The Meaning of Life&amp;quot;, &amp;quot;age&amp;quot;: 1983}
foo(**person)
foo(**{&amp;quot;name&amp;quot;: &amp;quot;Brian&amp;quot;, &amp;quot;age&amp;quot;: 30})

foo(**{&amp;quot;name&amp;quot;: &amp;quot;Brian&amp;quot;})  # expect-type-error
person2: dict[str, object] = {&amp;quot;name&amp;quot;: &amp;quot;Brian&amp;quot;, &amp;quot;age&amp;quot;: 20}
foo(**person2)  # expect-type-error
foo(**{&amp;quot;name&amp;quot;: &amp;quot;Brian&amp;quot;, &amp;quot;age&amp;quot;: &amp;quot;1979&amp;quot;})  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;typevartuple&quot;&gt;TypeVarTuple&lt;a class=&quot;zola-anchor&quot; href=&quot;#typevartuple&quot; aria-label=&quot;Anchor link for: typevartuple&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;TypeVarTuple 可以定义“变长元组”（variadic tuples）类型。这种类型提示可以捕获多个
类型，并且允许元组长度动态变化。它类似于泛型中的 TypeVar，但 TypeVarTuple 是专门
用于处理可变数量的类型参数的。&lt;&#x2F;p&gt;
&lt;p&gt;TypeVarTuple 用于定义一组任意数量的类型参数，它们可以一起表示一个变长的元组或任
意长的参数列表。&lt;&#x2F;p&gt;
&lt;p&gt;TypeVarTuple 定义一个类型元组，它可以代表任意数量的类型。
Unpack 用于从 TypeVarTuple 中提取类型参数，并应用到函数或类中。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shi-li&quot;&gt;示例&lt;a class=&quot;zola-anchor&quot; href=&quot;#shi-li&quot; aria-label=&quot;Anchor link for: shi-li&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;定义一个函数，它接受一个 Tuple，其中的元素可以是任意类型，并返回这个元组。我们可
以使用 TypeVarTuple 来定义这样一个函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import TypeVarTuple, Tuple, Unpack

Ts = TypeVarTuple(&amp;#x27;Ts&amp;#x27;)  # 定义一个类型元组 Ts

def my_tuple_func(t: Tuple[Unpack[Ts]]) -&amp;gt; Tuple[Unpack[Ts]]:
    return t

# 我们可以使用这个函数处理不同类型和长度的元组：
print(my_tuple_func((1, &amp;#x27;a&amp;#x27;, 3.14)))  # 输出：(1, &amp;#x27;a&amp;#x27;, 3.14)
print(my_tuple_func((True,)))         # 输出：(True,)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这个例子中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ts = TypeVarTuple(&#x27;Ts&#x27;)&lt;&#x2F;code&gt; 定义了一个类型变量 &lt;code&gt;Ts&lt;&#x2F;code&gt;，它可以代表一组类型。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;my_tuple_func&lt;&#x2F;code&gt; 函数接受一个 Tuple，这个元组的类型是由 &lt;code&gt;Unpack[Ts]&lt;&#x2F;code&gt; 解包的。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Tuple[Unpack[Ts]]&lt;&#x2F;code&gt; 表示这个元组可以包含多个类型。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;shi-li-2&quot;&gt;示例 2&lt;a class=&quot;zola-anchor&quot; href=&quot;#shi-li-2&quot; aria-label=&quot;Anchor link for: shi-li-2&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Define an `Array` type that supports element-wise addition of arrays with identical dimensions and types.
&amp;quot;&amp;quot;&amp;quot;

from typing import Generic, TypeVar, TypeVarTuple, assert_type

T = TypeVar(&amp;quot;T&amp;quot;)
Ts = TypeVarTuple(&amp;quot;Ts&amp;quot;)


class Array(Generic[*Ts]):
    def __add__(self, other: &amp;quot;Array[*Ts]&amp;quot;) -&amp;gt; &amp;quot;Array[*Ts]&amp;quot;:
        ...


## End of your code ##
from typing import assert_type

a: Array[float, int] = Array()
b: Array[float, int] = Array()
assert_type(a + b, Array[float, int])

c: Array[float, int, str] = Array()
assert_type(a + c, Array[float, int, str])  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;P = ParamSpec(&amp;#x27;P&amp;#x27;)
R = TypeVar(&amp;#x27;R&amp;#x27;)

def add_logging(f: Callable[P, R]) -&amp;gt; Callable[P, R]:
    ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;typeguard&quot;&gt;TypeGuard&lt;a class=&quot;zola-anchor&quot; href=&quot;#typeguard&quot; aria-label=&quot;Anchor link for: typeguard&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;TypeGuard&lt;&#x2F;code&gt; 是一种类型提示，用于告诉类型检查器某个函数在运行时能够对变量的类型进
行校验和收缩。它通常用于类型推断工具（例如 &lt;code&gt;mypy&lt;&#x2F;code&gt;）来缩小类型范围。&lt;&#x2F;p&gt;
&lt;p&gt;假设我们有一个函数 &lt;code&gt;is_str_list&lt;&#x2F;code&gt;，它接受一个 &lt;code&gt;list&lt;&#x2F;code&gt; 并检查该列表中的所有元素是否都是
字符串。我们希望在通过该检查后，类型检查器能够推断出列表是由字符串组成的。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import List, TypeGuard, Union

def is_str_list(values: List[Union[str, int]]) -&amp;gt; TypeGuard[List[str]]:
    return all(isinstance(v, str) for v in values)

# 使用示例
my_list: List[Union[str, int]] = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, 1]

if is_str_list(my_list):
    # 这里类型检查器会推断 my_list 的类型为 List[str]
    print(&amp;quot;All elements are strings&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这个例子中：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;is_str_list&lt;&#x2F;code&gt; 是一个自定义类型守卫函数，使用 &lt;code&gt;TypeGuard&lt;&#x2F;code&gt; 来标注返回值。
返回类型 &lt;code&gt;TypeGuard[List[str]]&lt;&#x2F;code&gt; 告诉类型检查器，如果 &lt;code&gt;is_str_list&lt;&#x2F;code&gt; 返回 &lt;code&gt;True&lt;&#x2F;code&gt;，
则传入的 &lt;code&gt;values&lt;&#x2F;code&gt; 类型会被认为是 &lt;code&gt;List[str]&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;因此，当我们在 &lt;code&gt;if&lt;&#x2F;code&gt; 语句中调用 &lt;code&gt;is_str_list&lt;&#x2F;code&gt; 后，&lt;code&gt;my_list&lt;&#x2F;code&gt; 的类型会自动缩小到
&lt;code&gt;List[str]&lt;&#x2F;code&gt;，而不再是最初的 &lt;code&gt;List[Union[str, int]]&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lei&quot;&gt;类&lt;a class=&quot;zola-anchor&quot; href=&quot;#lei&quot; aria-label=&quot;Anchor link for: lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;classvar&quot;&gt;ClassVar&lt;a class=&quot;zola-anchor&quot; href=&quot;#classvar&quot; aria-label=&quot;Anchor link for: classvar&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;ClassVar&lt;&#x2F;code&gt; 注解是指，给定属性应当用作类变量，而不应设置在类实例上。用法如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class Starship:
    stats: ClassVar[dict[str, int]] = {} # 类变量
    damage: int = 10                     # 实例变量
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Class `Foo` has a class variable `bar`, which is an integer.
&amp;quot;&amp;quot;&amp;quot;
from typing import ClassVar


class Foo:
    bar: ClassVar[int]
    &amp;quot;&amp;quot;&amp;quot;Hint: No need to write __init__&amp;quot;&amp;quot;&amp;quot;


## End of your code ##
Foo.bar = 1
Foo.bar = &amp;quot;1&amp;quot;  # expect-type-error
Foo().bar = 1  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;self&quot;&gt;Self&lt;a class=&quot;zola-anchor&quot; href=&quot;#self&quot; aria-label=&quot;Anchor link for: self&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;表示当前闭包内的类&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import Self, reveal_type

class Foo:
    def return_self(self) -&amp;gt; Self:
        ...
        return self

class SubclassOfFoo(Foo): pass

reveal_type(Foo().return_self())  # 揭示的类型为 &amp;quot;Foo&amp;quot;
reveal_type(SubclassOfFoo().return_self())  # 揭示的类型为 &amp;quot;SubclassOfFoo&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此注解在语法上等价于以下代码，但形式更为简洁：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import TypeVar

Self = TypeVar(&amp;quot;Self&amp;quot;, bound=&amp;quot;Foo&amp;quot;)

class Foo:
    def return_self(self: Self) -&amp;gt; Self:
        ...
        return self
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通常来说，如果某些内容返回 &lt;code&gt;self&lt;&#x2F;code&gt;，如上面的示例所示，您应该使用 &lt;code&gt;Self&lt;&#x2F;code&gt; 作为返回
值注解。如果 &lt;code&gt;Foo.return_self&lt;&#x2F;code&gt; 被注解为返回 &lt;code&gt;&quot;Foo&quot;&lt;&#x2F;code&gt;，那么类型检查器将推断从
&lt;code&gt;SubclassOfFoo.return_self&lt;&#x2F;code&gt; 返回的对象是 &lt;code&gt;Foo&lt;&#x2F;code&gt; 类型，而不是 &lt;code&gt;SubclassOfFoo&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;challenge:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

`return_self` should return an instance of the same type as the current enclosed class.
&amp;quot;&amp;quot;&amp;quot;

from typing import Self


class Foo:
    def return_self(self) -&amp;gt; Self:
        ...


# Another solution using TypeVar
# from typing import TypeVar
#
# T = TypeVar(&amp;#x27;T&amp;#x27;, bound=&amp;#x27;Foo&amp;#x27;)
#
# class Foo:
#     def return_self(self: T) -&amp;gt; T:
#         ...


## End of your code ##
class SubclassOfFoo(Foo):
    pass


f: Foo = Foo().return_self()
sf: SubclassOfFoo = SubclassOfFoo().return_self()

sf: SubclassOfFoo = Foo().return_self()  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;fan-xing-generic&quot;&gt;泛型（Generic）&lt;a class=&quot;zola-anchor&quot; href=&quot;#fan-xing-generic&quot; aria-label=&quot;Anchor link for: fan-xing-generic&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;typevar-1&quot;&gt;TypeVar&lt;a class=&quot;zola-anchor&quot; href=&quot;#typevar-1&quot; aria-label=&quot;Anchor link for: typevar-1&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;TypeVar&lt;&#x2F;code&gt; 可以用来定义一个类型变量，它可以代表任意类型，并且可以在多个地方重用。&lt;&#x2F;p&gt;
&lt;p&gt;泛型函数和类可以通过使用 &lt;code&gt;类型形参语法&lt;&#x2F;code&gt; 来实现参数化:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from collections.abc import Sequence

def first[T](l: Sequence[T]) -&amp;gt; T:  # 函数是 TypeVar &amp;quot;T&amp;quot; 泛型
    return l[0]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;TypeVar&lt;&#x2F;code&gt; 提供 &lt;code&gt;bound&lt;&#x2F;code&gt; 参数可以约束它只能是某种类型的子类。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;
from typing import TypeVar

# T 必须是 int 或其子类
T = TypeVar(&amp;#x27;T&amp;#x27;, bound=int)

def double(x: T) -&amp;gt; T:
    return x * 2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fan-xing-han-shu-generic-functions&quot;&gt;泛型函数（Generic Functions）&lt;a class=&quot;zola-anchor&quot; href=&quot;#fan-xing-han-shu-generic-functions&quot; aria-label=&quot;Anchor link for: fan-xing-han-shu-generic-functions&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import TypeVar

T = TypeVar(&amp;#x27;T&amp;#x27;)  # 定义一个泛型 T

def identity(x: T) -&amp;gt; T:
    return x

# &amp;gt;= 3.12 推荐写法
def identity[T](x: T) -&amp;gt; T:
    return x
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fan-xing-lei&quot;&gt;泛型类&lt;a class=&quot;zola-anchor&quot; href=&quot;#fan-xing-lei&quot; aria-label=&quot;Anchor link for: fan-xing-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;在泛型类中，类的属性和方法可以适应不同的数据类型。通过 Generic 类，我们可以将类
声明为泛型类。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fan-xing-lei-ding-yi&quot;&gt;泛型类定义&lt;a class=&quot;zola-anchor&quot; href=&quot;#fan-xing-lei-ding-yi&quot; aria-label=&quot;Anchor link for: fan-xing-lei-ding-yi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;例如，我们可以定义一个简单的容器类，它能够存储任意类型的数据：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from logging import Logger

# `T` 是类体内部有效的类型
class LoggedVar[T]:
    def __init__(self, value: T, name: str, logger: Logger) -&amp;gt; None:
        self.name = name
        self.logger = logger
        self.value = value

    def set(self, new: T) -&amp;gt; None:
        self.log(&amp;#x27;Set &amp;#x27; + repr(self.value))
        self.value = new

    def get(self) -&amp;gt; T:
        self.log(&amp;#x27;Get &amp;#x27; + repr(self.value))
        return self.value

    def log(self, message: str) -&amp;gt; None:
        self.logger.info(&amp;#x27;%s: %s&amp;#x27;, self.name, message)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;泛型类隐式继承自 &lt;code&gt;Generic&lt;&#x2F;code&gt;。为了与 Python 3.11 及更低版本兼容，也允许显式地从
&lt;code&gt;Generic&lt;&#x2F;code&gt; 继承以表示泛型类：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import TypeVar, Generic

T = TypeVar(&amp;#x27;T&amp;#x27;)

class LoggedVar(Generic[T]):
    ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;fan-xing-he-ji-cheng&quot;&gt;泛型和继承&lt;a class=&quot;zola-anchor&quot; href=&quot;#fan-xing-he-ji-cheng&quot; aria-label=&quot;Anchor link for: fan-xing-he-ji-cheng&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;在面向对象编程中，泛型类可以与继承结合使用，允许子类继承父类的泛型行为。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import Generic, TypeVar

T = TypeVar(&amp;#x27;T&amp;#x27;)

class Animal(Generic[T]):
    def speak(self, sound: T) -&amp;gt; None:
        print(f&amp;quot;The animal says {sound}&amp;quot;)

class Dog(Animal[str]):
    pass

dog = Dog()
dog.speak(&amp;quot;woof&amp;quot;)  # 输出：The animal says woof
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;Animal&lt;&#x2F;code&gt; 是一个泛型类，&lt;code&gt;Dog&lt;&#x2F;code&gt; 继承了 &lt;code&gt;Animal&lt;&#x2F;code&gt;，并将泛型 &lt;code&gt;T&lt;&#x2F;code&gt; 限定为
&lt;code&gt;str&lt;&#x2F;code&gt; 类型。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;overload&quot;&gt;overload&lt;a class=&quot;zola-anchor&quot; href=&quot;#overload&quot; aria-label=&quot;Anchor link for: overload&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;@overload&lt;&#x2F;code&gt; 装饰器可以用来声明同一函数的多个版本，每个版本有不同的参数类型和返回值
类型，但在运行时不会实际执行。mypy 会根据参数类型来推断正确的类型签名。&lt;&#x2F;p&gt;
&lt;p&gt;非 &lt;code&gt;@overload&lt;&#x2F;code&gt; 装饰的定义将在运行时使用但应被类型检查器忽略。在运行时，直接调用以
&lt;code&gt;@overload&lt;&#x2F;code&gt; 装饰的函数将引发 NotImplementedError。&lt;&#x2F;p&gt;
&lt;p&gt;challenge:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:
`process` is a function that takes one argument `response`
- When `response` is bytes, `process` returns a string
- When `response` is an integer, `process` returns tuple[int, str]
- When `response` is None, `process` returns None
&amp;quot;&amp;quot;&amp;quot;
from typing import overload


@overload
def process(response: None) -&amp;gt; None:
    ...


@overload
def process(response: int) -&amp;gt; tuple[int, str]:
    ...


@overload
def process(response: bytes) -&amp;gt; str:
    ...


def process(response: int | bytes | None) -&amp;gt; str | None | tuple[int, str]:
    ...


## End of your code ##
from typing import assert_type

assert_type(process(b&amp;quot;42&amp;quot;), str)
assert_type(process(42), tuple[int, str])
assert_type(process(None), None)

assert_type(process(42), str)  # expect-type-error
assert_type(process(None), str)  # expect-type-error
assert_type(process(b&amp;quot;42&amp;quot;), tuple[int, str])  # expect-type-error
assert_type(process(None), tuple[int, str])  # expect-type-error
assert_type(process(42), str)  # expect-type-error
assert_type(process(None), str)  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;protocol&quot;&gt;Protocol&lt;a class=&quot;zola-anchor&quot; href=&quot;#protocol&quot; aria-label=&quot;Anchor link for: protocol&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;用于定义“结构化子类型”（structural subtyping），也称为“鸭子类型”。&lt;code&gt;Protocol&lt;&#x2F;code&gt;  允
许我们通过“接口”来定义一个类型，而不强制要求对象必须显式继承这些接口。只要一个对
象实现了所需的方法或属性，它就可以被认为符合某个 &lt;code&gt;Protocol&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:
    Define a protocol for class `SupportsQuack` that supports a &amp;quot;quack&amp;quot; method.
&amp;quot;&amp;quot;&amp;quot;

from typing import Protocol


class SupportsQuack(Protocol):
    def quack(self) -&amp;gt; None:
        ...


## End of your code ##
class Duck:
    def quack(self) -&amp;gt; None:
        print(&amp;quot;quack!&amp;quot;)


class Dog:
    def bark(self) -&amp;gt; None:
        print(&amp;quot;bark!&amp;quot;)


duck: SupportsQuack = Duck()
dog: SupportsQuack = Dog()  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;callable-protocol&quot;&gt;callable-protocol&lt;a class=&quot;zola-anchor&quot; href=&quot;#callable-protocol&quot; aria-label=&quot;Anchor link for: callable-protocol&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Define a callable type that accepts a string parameter called `name` and returns None.
&amp;quot;&amp;quot;&amp;quot;
from typing import Protocol


class SingleStringInput(Protocol):
    def __call__(self, name: str) -&amp;gt; None:
        ...


## End of your code ##
def accept_single_string_input(func: SingleStringInput) -&amp;gt; None:
    func(name=&amp;quot;name&amp;quot;)


def string_name(name: str) -&amp;gt; None:
    ...


def string_value(value: str) -&amp;gt; None:
    ...


def return_string(name: str) -&amp;gt; str:
    return name


accept_single_string_input(string_name)
accept_single_string_input(string_value)  # expect-type-error
accept_single_string_input(return_string)  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;typeddict&quot;&gt;TypedDict&lt;a class=&quot;zola-anchor&quot; href=&quot;#typeddict&quot; aria-label=&quot;Anchor link for: typeddict&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;TypedDict 声明一个字典类型，字典定义一个具有特定键和值类型的字典结构，可以像定义
类一样定义字典的键和值的类型，确保字典的键和值符合预期。 可以使用 NotRequired 将
单独的键标记为非必要。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Define a class `Student` that represents a dictionary with three keys:
- name, a string
- age, an integer
- school, a string
&amp;quot;&amp;quot;&amp;quot;
from typing import TypedDict

class Student(TypedDict):
    name: str
    age: int
    school: str

a: Student = {&amp;quot;name&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: 15, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}
a: Student = {&amp;quot;name&amp;quot;: 1, &amp;quot;age&amp;quot;: 15, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}  # expect-type-error
a: Student = {(1,): &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: 2, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}  # expect-type-error
a: Student = {&amp;quot;name&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}  # expect-type-error
a: Student = {&amp;quot;name&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: 2}  # expect-type-error
assert Student(name=&amp;quot;Tom&amp;quot;, age=15, school=&amp;quot;Hogwarts&amp;quot;) == dict(
    name=&amp;quot;Tom&amp;quot;, age=15, school=&amp;quot;Hogwarts&amp;quot;
)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;默认情况下，所有的键都必须出现在一个 TypedDict 中。可以使用 NotRequired 将单独
的键标记为非必要&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Define a class `Student` that represents a dictionary with three keys:
- name, a string
- age, an integer
- school, a string

Note: school can be optional
&amp;quot;&amp;quot;&amp;quot;

from typing import TypedDict, NotRequired

class Student(TypedDict):
    name: str
    age: int
    school: NotRequired[str]

a: Student = {&amp;quot;name&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: 15}
a: Student = {&amp;quot;name&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: 15, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}
a: Student = {&amp;quot;name&amp;quot;: 1, &amp;quot;age&amp;quot;: 15, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}  # expect-type-error
a: Student = {(1,): &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: 2, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}  # expect-type-error
a: Student = {&amp;quot;name&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;school&amp;quot;: &amp;quot;Hogwarts&amp;quot;}  # expect-type-error
a: Student = {&amp;quot;z&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;age&amp;quot;: 2}  # expect-type-error
assert Student(name=&amp;quot;Tom&amp;quot;, age=15) == dict(name=&amp;quot;Tom&amp;quot;, age=15)
assert Student(name=&amp;quot;Tom&amp;quot;, age=15, school=&amp;quot;Hogwarts&amp;quot;) == dict(
    name=&amp;quot;Tom&amp;quot;, age=15, school=&amp;quot;Hogwarts&amp;quot;
)

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;使用 total=False 时，TypedDict 中单独的键可以使用 Required 标记为必要的&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Define a class `Person` that represents a dictionary with five string keys:
    name, age, gender, address, email

The value of each key must be the specified type:
    name - str, age - int, gender - str, address - str, email - str

Note: Only `name` is required
&amp;quot;&amp;quot;&amp;quot;

from typing import TypedDict, Required


class Person(TypedDict, total=False):
    name: Required[str]
    age: int
    gender: str
    address: str
    email: str


# Alternative soltion:
#
# Person = TypedDict(&amp;#x27;Person&amp;#x27;, {
#     name: Required[str],
#     age: int,
#     gender: str,
#     address: str,
#     email: str,
# }, total=False):

## End of your code ##
a: Person = {
    &amp;quot;name&amp;quot;: &amp;quot;Capy&amp;quot;,
    &amp;quot;age&amp;quot;: 1,
    &amp;quot;gender&amp;quot;: &amp;quot;Male&amp;quot;,
    &amp;quot;address&amp;quot;: &amp;quot;earth&amp;quot;,
    &amp;quot;email&amp;quot;: &amp;quot;capy@bara.com&amp;quot;,
}
a: Person = {&amp;quot;name&amp;quot;: &amp;quot;Capy&amp;quot;}
a: Person = {&amp;quot;age&amp;quot;: 1, &amp;quot;gender&amp;quot;: &amp;quot;Male&amp;quot;, &amp;quot;address&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;email&amp;quot;: &amp;quot;&amp;quot;} # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;qi-ta&quot;&gt;其他&lt;a class=&quot;zola-anchor&quot; href=&quot;#qi-ta&quot; aria-label=&quot;Anchor link for: qi-ta&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;literal&quot;&gt;Literal&lt;a class=&quot;zola-anchor&quot; href=&quot;#literal&quot; aria-label=&quot;Anchor link for: literal&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;特殊类型注解形式，用于定义“字面值类型”。&lt;&#x2F;p&gt;
&lt;p&gt;Literal 可以用来向类型检查器说明被注解的对象具有与所提供的字面量之一相同的值。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def validate_simple(data: Any) -&amp;gt; Literal[True]:  # 总是返回 True
    ...

type Mode = Literal[&amp;#x27;r&amp;#x27;, &amp;#x27;rb&amp;#x27;, &amp;#x27;w&amp;#x27;, &amp;#x27;wb&amp;#x27;]
def open_helper(file: str, mode: Mode) -&amp;gt; str:
    ...

open_helper(&amp;#x27;&amp;#x2F;some&amp;#x2F;path&amp;#x27;, &amp;#x27;r&amp;#x27;)      # 通过类型检查
open_helper(&amp;#x27;&amp;#x2F;other&amp;#x2F;path&amp;#x27;, &amp;#x27;typo&amp;#x27;)  # 类型检查错误
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;literalstring&quot;&gt;LiteralString&lt;a class=&quot;zola-anchor&quot; href=&quot;#literalstring&quot; aria-label=&quot;Anchor link for: literalstring&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;只包括字符串字面值的的特殊类型。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def run_query(sql: LiteralString) -&amp;gt; None:
    ...

def caller(arbitrary_string: str, literal_string: LiteralString) -&amp;gt; None:
    run_query(&amp;quot;SELECT * FROM students&amp;quot;)  # 可以
    run_query(literal_string)  # 可以
    run_query(&amp;quot;SELECT * FROM &amp;quot; + literal_string)  # 可以
    run_query(arbitrary_string)  # 类型检查器错误
    run_query(  # 类型检查器错误
        f&amp;quot;SELECT * FROM students WHERE name = {arbitrary_string}&amp;quot;
    )
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;LiteralString 对于会因用户可输入任意字符串而导致问题的敏感 API 很有用。例如，上
述两处导致类型检查器报错的代码可能容易被 SQL 注入攻击。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhuang-shi-qi-decorator&quot;&gt;装饰器（decorator）&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhuang-shi-qi-decorator&quot; aria-label=&quot;Anchor link for: zhuang-shi-qi-decorator&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

定义一个装饰器，它包装一个函数并返回一个具有相同签名的函数。
&amp;quot;&amp;quot;&amp;quot;
from typing import Callable, TypeVar

# For Python &amp;lt; 3.12
#
# T = TypeVar(&amp;quot;T&amp;quot;, bound=Callable)
#
# def decorator(func: T) -&amp;gt; T:
#     return func


# For Python &amp;gt;= 3.12
def decorator[T: Callable](func: T) -&amp;gt; T:
    return func


## End of your code ##
@decorator
def foo(a: int, *, b: str) -&amp;gt; None:
    ...


@decorator
def bar(c: int, d: str) -&amp;gt; None:
    ...


foo(1, b=&amp;quot;2&amp;quot;)
bar(c=1, d=&amp;quot;2&amp;quot;)

foo(1, &amp;quot;2&amp;quot;)  # expect-type-error
foo(a=1, e=&amp;quot;2&amp;quot;)  # expect-type-error
decorator(1)  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;TODO:&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

定义一个装饰器，它包装一个函数并返回一个具有相同签名的函数。
这个装饰器接受一个名为 `message` 的字符串类型参数。
&amp;quot;&amp;quot;&amp;quot;
from collections.abc import Callable
from typing import TypeVar

# For Python &amp;lt; 3.12
#
# T = TypeVar(&amp;quot;T&amp;quot;, bound=Callable)
#
# def decorator(message: str) -&amp;gt; Callable[[T], T]:
#     return func


# For Python &amp;gt;= 3.12
def decorator[T: Callable](message: str) -&amp;gt; Callable[[T], T]:
    ...


## End of your code ##
@decorator(message=&amp;quot;x&amp;quot;)
def foo(a: int, *, b: str) -&amp;gt; None:
    ...


@decorator  # expect-type-error
def bar(a: int, *, b: str) -&amp;gt; None:
    ...


foo(1, b=&amp;quot;2&amp;quot;)
foo(1, &amp;quot;2&amp;quot;)  # expect-type-error
foo(a=1, e=&amp;quot;2&amp;quot;)  # expect-type-error
decorator(1)  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;miao-shu-qi-descriptor&quot;&gt;描述器（descriptor）&lt;a class=&quot;zola-anchor&quot; href=&quot;#miao-shu-qi-descriptor&quot; aria-label=&quot;Anchor link for: miao-shu-qi-descriptor&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Self&lt;&#x2F;code&gt; 是一个特殊类型，表示当前闭包内的类。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import Self, reveal_type

class Foo:
    def return_self(self) -&amp;gt; Self:
        ...
        return self

class SubclassOfFoo(Foo): pass

reveal_type(Foo().return_self())  # 揭示的类型为 &amp;quot;Foo&amp;quot;
reveal_type(SubclassOfFoo().return_self())  # 揭示的类型为 &amp;quot;SubclassOfFoo&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此注解在语法上等价于以下代码，但形式更为简洁：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import TypeVar

Self = TypeVar(&amp;quot;Self&amp;quot;, bound=&amp;quot;Foo&amp;quot;)

class Foo:
    def return_self(self: Self) -&amp;gt; Self:
        ...
        return self
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Create a descriptor and annotate the __get__ method.
&amp;quot;&amp;quot;&amp;quot;

from typing import Any, Self, overload


class Descriptor:
    # 如果 instance 是 None,表示是通过类访问的，返回描述符自身 (self)
    @overload
    def __get__(self, instance: None, owner: type) -&amp;gt; Self:
        ...

    # 通过实例访问的，返回一个字符串 &amp;quot;描述符值&amp;quot;
    @overload
    def __get__(self, instance: Any, owner: type) -&amp;gt; str:
        ...

    def __get__(self, instance: Any, owner: type) -&amp;gt; Self | str:
        ...


## End of your code ##
class TestClass:
    a = Descriptor()


def descriptor_self(x: Descriptor) -&amp;gt; None:
    ...


def string_value(x: str) -&amp;gt; None:
    ...


descriptor_self(TestClass.a)
string_value(TestClass().a)
descriptor_self(TestClass().a)  # expect-type-error
string_value(TestClass.a)  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;sheng-cheng-qi-generator&quot;&gt;生成器（generator）&lt;a class=&quot;zola-anchor&quot; href=&quot;#sheng-cheng-qi-generator&quot; aria-label=&quot;Anchor link for: sheng-cheng-qi-generator&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;生成器可以使用泛型类型 &lt;code&gt;Generator[YieldType, SendType, ReturnType]&lt;&#x2F;code&gt; 来标。 例如:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def echo_round() -&amp;gt; Generator[int, float, str]:
    sent = yield 0
    while sent &amp;gt;= 0:
        sent = yield round(sent)
    return &amp;#x27;Done&amp;#x27;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

`gen` is a generator that yields a integer, and can accept a string sent to it.
It does not return anything.
&amp;quot;&amp;quot;&amp;quot;

from collections.abc import Generator


def gen() -&amp;gt; Generator[int, str, None]:
    &amp;quot;&amp;quot;&amp;quot;You don&amp;#x27;t need to implement it&amp;quot;&amp;quot;&amp;quot;
    ...


## End of your code ##
from typing import assert_type

generator = gen()
assert_type(next(generator), int)
generator.send(&amp;quot;sss&amp;quot;)
generator.send(3)  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;never&quot;&gt;never&lt;a class=&quot;zola-anchor&quot; href=&quot;#never&quot; aria-label=&quot;Anchor link for: never&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;Never 和 NoReturn 代表 底类型(Bottom Type)，一种没有成员的类型。
它们可被用于指明一个函数绝不会返回，例如 sys.exit():&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import Never  # 或 NoReturn

def stop() -&amp;gt; Never:
    raise RuntimeError(&amp;#x27;no way&amp;#x27;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;或者用于定义一个绝不应被调用的函数，因为不存在有效的参数，例如 assert_never():&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import Never  # 或 NoReturn

def never_call_me(arg: Never) -&amp;gt; None:
    pass

def int_or_str(arg: int | str) -&amp;gt; None:
    never_call_me(arg)  # 类型检查器错误
    match arg:
        case int():
            print(&amp;quot;It&amp;#x27;s an int&amp;quot;)
        case str():
            print(&amp;quot;It&amp;#x27;s a str&amp;quot;)
        case _:
            never_call_me(arg)  # OK, arg is of type Never (or NoReturn)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Never 和 NoReturn 在类型系统中具有相同的含义并且静态类型检查器会以相同的方式对待这两者。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;buffer&quot;&gt;buffer&lt;a class=&quot;zola-anchor&quot; href=&quot;#buffer&quot; aria-label=&quot;Anchor link for: buffer&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;docs.python.org&#x2F;zh-cn&#x2F;3&#x2F;c-api&#x2F;buffer.html#bufferobjects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&amp;quot;&amp;quot;&amp;quot;
TODO:

Annotate the function `read_buffer`, which accepts anything that is a buffer.

See https:&amp;#x2F;&amp;#x2F;docs.python.org&amp;#x2F;3.12&amp;#x2F;reference&amp;#x2F;datamodel.html#object.__buffer__
&amp;quot;&amp;quot;&amp;quot;

from collections.abc import Buffer


def read_buffer(b: Buffer):
    ...


## End of your code ##

from array import array


class MyBuffer:
    def __init__(self, data: bytes):
        self.data = bytearray(data)
        self.view = None

    def __buffer__(self, flags: int) -&amp;gt; memoryview:
        self.view = memoryview(self.data)
        return self.view


read_buffer(b&amp;quot;foo&amp;quot;)
read_buffer(memoryview(b&amp;quot;foo&amp;quot;))
read_buffer(array(&amp;quot;l&amp;quot;, [1, 2, 3, 4, 5]))
read_buffer(MyBuffer(b&amp;quot;foo&amp;quot;))
read_buffer(&amp;quot;foo&amp;quot;)  # expect-type-error
read_buffer(1)  # expect-type-error
read_buffer([&amp;quot;foo&amp;quot;])  # expect-type-error
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;todo-xie-bian-ni-bian-bu-bian-covariant-contravariant-invariant&quot;&gt;TODO: 协变，逆变，不变(covariant, contravariant, invariant)&lt;a class=&quot;zola-anchor&quot; href=&quot;#todo-xie-bian-ni-bian-bu-bian-covariant-contravariant-invariant&quot; aria-label=&quot;Anchor link for: todo-xie-bian-ni-bian-bu-bian-covariant-contravariant-invariant&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;pai-cha-gong-ju&quot;&gt;排查工具&lt;a class=&quot;zola-anchor&quot; href=&quot;#pai-cha-gong-ju&quot; aria-label=&quot;Anchor link for: pai-cha-gong-ju&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;shi-yong-reveal-type-cha-kan-tui-duan-lei-xing&quot;&gt;使用 &lt;code&gt;reveal_type&lt;&#x2F;code&gt; 查看推断类型&lt;a class=&quot;zola-anchor&quot; href=&quot;#shi-yong-reveal-type-cha-kan-tui-duan-lei-xing&quot; aria-label=&quot;Anchor link for: shi-yong-reveal-type-cha-kan-tui-duan-lei-xing&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;a = [4]
reveal_type(a)         # -&amp;gt; error: Revealed type is &amp;#x27;builtins.list[builtins.int*]&amp;#x27;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shi-yong-cast-lai-qiang-zhi-zhi-ding-lei-xing&quot;&gt;使用 &lt;code&gt;cast&lt;&#x2F;code&gt; 来强制指定类型：&lt;a class=&quot;zola-anchor&quot; href=&quot;#shi-yong-cast-lai-qiang-zhi-zhi-ding-lei-xing&quot; aria-label=&quot;Anchor link for: shi-yong-cast-lai-qiang-zhi-zhi-ding-lei-xing&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from typing import List, cast
a = [4]
b = cast(List[int], a) # passes fine
c = cast(List[str], a) # type: List[str] # passes fine (no runtime check)
reveal_type(c)         # -&amp;gt; error: Revealed type is &amp;#x27;builtins.list[builtins.str]&amp;#x27;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;shi-yong-lei-xing-hu-lue-biao-ji-jin-yong-yi-xing-zhong-de-cuo-wu&quot;&gt;使用类型忽略标记禁用一行中的错误：&lt;a class=&quot;zola-anchor&quot; href=&quot;#shi-yong-lei-xing-hu-lue-biao-ji-jin-yong-yi-xing-zhong-de-cuo-wu&quot; aria-label=&quot;Anchor link for: shi-yong-lei-xing-hu-lue-biao-ji-jin-yong-yi-xing-zhong-de-cuo-wu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;x = confusing_function() # type: ignore # see mypy&amp;#x2F;issues&amp;#x2F;1167
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;sheng-cheng-type-annotation&quot;&gt;生成 type annotation&lt;a class=&quot;zola-anchor&quot; href=&quot;#sheng-cheng-type-annotation&quot; aria-label=&quot;Anchor link for: sheng-cheng-type-annotation&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mypy stubgen&lt;&#x2F;code&gt; &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;mypy&#x2F;blob&#x2F;master&#x2F;mypy&#x2F;stubgen.py&quot;&gt;mypy&#x2F;mypy&#x2F;stubgen.py at master · python&#x2F;mypy&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;monkeytype&lt;&#x2F;code&gt; &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Instagram&#x2F;MonkeyType&quot;&gt;Instagram&#x2F;MonkeyType: A Python library that generates static type annotations by collecting runtime types&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;yi-xie-lei-xing-jian-cha-gong-ju&quot;&gt;一些类型检查工具&lt;a class=&quot;zola-anchor&quot; href=&quot;#yi-xie-lei-xing-jian-cha-gong-ju&quot; aria-label=&quot;Anchor link for: yi-xie-lei-xing-jian-cha-gong-ju&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mypy-lang.org&#x2F;&quot;&gt;mypy - Optional Static Typing for Python&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;pyright&quot;&gt;microsoft&#x2F;pyright: Static Type Checker for Python&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;pyre-check&quot;&gt;facebook&#x2F;pyre-check: Performant type-checking for python.&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;pytype&quot;&gt;google&#x2F;pytype: A static type analyzer for Python code&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;hr &#x2F;&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>小吃类</title>
		<published>2024-08-17T00:00:00+00:00</published>
		<updated>2025-07-26T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0006-xiao-chi-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0006-xiao-chi-lei/</id>
		<content type="html">&lt;h1 id=&quot;xiao-chi-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;6&quot;&gt;小吃类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#xiao-chi-lei&quot; aria-label=&quot;Anchor link for: xiao-chi-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;kao-leng-mian-lai-pi-hou-ban&quot;&gt;烤冷面-赖皮猴版&lt;a class=&quot;zola-anchor&quot; href=&quot;#kao-leng-mian-lai-pi-hou-ban&quot; aria-label=&quot;Anchor link for: kao-leng-mian-lai-pi-hou-ban&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;利民蒜蓉辣酱 80 克，天山红番茄沙司 100 克，白糖 40 克，太太乐鸡粉 10 克，味精 10 克，耗油 6 克，户户辣椒酱 10 克，半颗粒孜然粉 4 克，玉米淀粉 2 克，雪碧 20 克，清水 130 克。在锅中搅拌均匀熬好&lt;&#x2F;li&gt;
&lt;li&gt;葱花香菜洋葱碎适量&lt;&#x2F;li&gt;
&lt;li&gt;锅中适量油，放入冷面，下面刺水加热变软，打鸡蛋，翻面刷酱料，撒葱花香菜洋葱碎，卷好刷酱料撒芝麻出锅，可以适量烹醋&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;kao-chuan&quot;&gt;烤串&lt;a class=&quot;zola-anchor&quot; href=&quot;#kao-chuan&quot; aria-label=&quot;Anchor link for: kao-chuan&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;mi-zhi-mei-rou&quot;&gt;蜜汁梅肉&lt;a class=&quot;zola-anchor&quot; href=&quot;#mi-zhi-mei-rou&quot; aria-label=&quot;Anchor link for: mi-zhi-mei-rou&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;猪梅花肉&lt;&#x2F;li&gt;
&lt;li&gt;蜂蜜，五香粉少量，海鲜酱油，香料油，红油，腐乳汁，葱姜水，淀粉&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;yang-rou-chuan-an-zhi&quot;&gt;羊肉串腌制&lt;a class=&quot;zola-anchor&quot; href=&quot;#yang-rou-chuan-an-zhi&quot; aria-label=&quot;Anchor link for: yang-rou-chuan-an-zhi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;洋葱，红油，底味盐，啤酒&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;jiang-you-sheng-jin&quot;&gt;酱油生筋&lt;a class=&quot;zola-anchor&quot; href=&quot;#jiang-you-sheng-jin&quot; aria-label=&quot;Anchor link for: jiang-you-sheng-jin&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;牛生筋，定刀切片，加柠檬汁盐糖豆油腌制后串串（葱油酱烤制），加孜然芝麻辣椒面&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;kao-shuang-jin&quot;&gt;烤双筋&lt;a class=&quot;zola-anchor&quot; href=&quot;#kao-shuang-jin&quot; aria-label=&quot;Anchor link for: kao-shuang-jin&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;牛板筋，牛蹄筋（亮筋），高压锅葱姜盐压熟（20-40 分钟）后串串&lt;&#x2F;li&gt;
&lt;li&gt;刷油烤制（勤翻面），刷冷面酱，孜然芝麻辣椒面&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;sheng-kao-ji-zhua&quot;&gt;生烤鸡爪&lt;a class=&quot;zola-anchor&quot; href=&quot;#sheng-kao-ji-zhua&quot; aria-label=&quot;Anchor link for: sheng-kao-ji-zhua&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;酱：蒜蓉，紫洋葱蓉，红太阳烧烤酱，辣妹子酱，海鲜酱油，香油，鸡汁，水&lt;&#x2F;li&gt;
&lt;li&gt;鸡爪清晰干净劈开串串&lt;&#x2F;li&gt;
&lt;li&gt;水分烤干刷油烤脆，再刷酱，撒芝麻孜然辣椒面&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>TODO</title>
		<published>2023-11-14T00:00:00+00:00</published>
		<updated>2024-08-17T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0005-todo/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0005-todo/</id>
		<content type="html">&lt;h1 id=&quot;todo&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;5&quot;&gt;TODO&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#todo&quot; aria-label=&quot;Anchor link for: todo&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h1 id=&quot;todo-blog-you-hua&quot;&gt;TODO: blog 优化&lt;a class=&quot;zola-anchor&quot; href=&quot;#todo-blog-you-hua&quot; aria-label=&quot;Anchor link for: todo-blog-you-hua&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
配置 MkDocs 作为笔记子目录&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
支持 issue DRAFT 标签，zola 编译时不渲染文章&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
issue 标签自动嵌入 zola 模板中&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
优化文件自动备份策略&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
测试图片嵌入&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
测试公式&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
申请域名&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
配置 CDN 加速&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
测试 Vercel 部署&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>蔬菜类</title>
		<published>2023-10-29T00:00:00+00:00</published>
		<updated>2024-09-01T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0003-shu-cai-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0003-shu-cai-lei/</id>
		<content type="html">&lt;h1 id=&quot;shu-cai-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;3&quot;&gt;蔬菜类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#shu-cai-lei&quot; aria-label=&quot;Anchor link for: shu-cai-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h1 id=&quot;guo-ren-bo-cai&quot;&gt;果仁菠菜&lt;a class=&quot;zola-anchor&quot; href=&quot;#guo-ren-bo-cai&quot; aria-label=&quot;Anchor link for: guo-ren-bo-cai&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;菠菜用刀拍，撕成丝，切2寸长。&lt;&#x2F;li&gt;
&lt;li&gt;下锅烫菠菜梗，开锅放菠菜叶，叶绿捞出。&lt;&#x2F;li&gt;
&lt;li&gt;料汁：拍蒜，熟花生，盐，海鲜酱油，少点醋，辣椒油，少点糖。&lt;&#x2F;li&gt;
&lt;li&gt;菠菜放凉，拧干水分再放料汁&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;tu-dou-qie-zi-jiang-dong-bei-chu-zi-da-peng-zuo-fa&quot;&gt;土豆茄子酱（东北厨子大鹏做法）&lt;a class=&quot;zola-anchor&quot; href=&quot;#tu-dou-qie-zi-jiang-dong-bei-chu-zi-da-peng-zuo-fa&quot; aria-label=&quot;Anchor link for: tu-dou-qie-zi-jiang-dong-bei-chu-zi-da-peng-zuo-fa&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;土豆改刀切小块，茄子撕成条。&lt;&#x2F;li&gt;
&lt;li&gt;锅中加豆油，猪肉碎煸炒（可选），加入茄子煸软乘出备用。&lt;&#x2F;li&gt;
&lt;li&gt;锅中留底油，加入葱姜片煸炒。小火加入花椒面，酱油，香其酱煸炒。放入清水，加入茄子和土豆。根据汤的咸淡看是否需要补盐&lt;&#x2F;li&gt;
&lt;li&gt;茄子土豆炖熟后捣成酱，注意锅中要留一些汤。快出锅时加入葱花，青椒碎，蒜沫，香菜沫&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>鱼虾海鲜河鲜类</title>
		<published>2023-10-29T00:00:00+00:00</published>
		<updated>2024-10-20T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0004-yu-xia-hai-xian-he-xian-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0004-yu-xia-hai-xian-he-xian-lei/</id>
		<content type="html">&lt;h1 id=&quot;yu-xia-hai-xian-he-xian-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;4&quot;&gt;鱼虾海鲜河鲜类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#yu-xia-hai-xian-he-xian-lei&quot; aria-label=&quot;Anchor link for: yu-xia-hai-xian-he-xian-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h1 id=&quot;todo&quot;&gt;TODO&lt;a class=&quot;zola-anchor&quot; href=&quot;#todo&quot; aria-label=&quot;Anchor link for: todo&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;jiang-you-shui-zhu-za-yu&quot;&gt;酱油水煮杂鱼&lt;a class=&quot;zola-anchor&quot; href=&quot;#jiang-you-shui-zhu-za-yu&quot; aria-label=&quot;Anchor link for: jiang-you-shui-zhu-za-yu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;小杂鱼改斜刀（叶子鱼，梭子鱼，刺中鱼，金线鱼，朱带，黄花，黄刺，银鲳鱼）&lt;&#x2F;li&gt;
&lt;li&gt;姜切丝，蒜，豆豉，小米辣切碎。萝卜干泡水切丁&lt;&#x2F;li&gt;
&lt;li&gt;糖，生抽，老抽，蚝油，花雕酒，水，葱油白胡椒调碗汁备用&lt;&#x2F;li&gt;
&lt;li&gt;锅烧热放底油，放入姜蒜豆豉小米椒，放入萝卜干，鱼（注意不需要煎鱼），倒入碗汁，小火煮制 5 分钟，出锅放葱段，葱油&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>猪肉类</title>
		<published>2023-09-21T00:00:00+00:00</published>
		<updated>2026-01-25T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0002-zhu-rou-lei/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0002-zhu-rou-lei/</id>
		<content type="html">&lt;h1 id=&quot;zhu-rou-lei&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;2&quot;&gt;猪肉类&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#zhu-rou-lei&quot; aria-label=&quot;Anchor link for: zhu-rou-lei&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;rou-bing-zheng-dan&quot;&gt;肉饼蒸蛋：&lt;a class=&quot;zola-anchor&quot; href=&quot;#rou-bing-zheng-dan&quot; aria-label=&quot;Anchor link for: rou-bing-zheng-dan&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主料：猪肉馅600克&lt;&#x2F;li&gt;
&lt;li&gt;辅料&amp;amp;调料：玉米粒100克，盐3克，糖2克，白胡椒少许，姜粉1克，老抽10毫升，生抽20毫升，鸡蛋三个，小葱少许，香油少许&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;tang-cu-pai-gu-cun-lu&quot;&gt;糖醋排骨（村驴）&lt;a class=&quot;zola-anchor&quot; href=&quot;#tang-cu-pai-gu-cun-lu&quot; aria-label=&quot;Anchor link for: tang-cu-pai-gu-cun-lu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主配料
&lt;ul&gt;
&lt;li&gt;净排 2 斤&lt;&#x2F;li&gt;
&lt;li&gt;葱姜&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;碗汁：冰糖 60g，白醋（5 度） 30g，生抽 40g，番茄沙司 30g，红腐乳汁 10g，老抽 4g&lt;&#x2F;li&gt;
&lt;li&gt;排骨泡去血水，沥干水分备用&lt;&#x2F;li&gt;
&lt;li&gt;锅中适量油，加姜片排骨煎至焦黄，烹料酒，加入碗汁，水炖煮 50-70分钟&lt;&#x2F;li&gt;
&lt;li&gt;大火收汁，再加入白醋 30g，白芝麻 10g 出锅&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;nong-jia-yi-wan-xiang-cun-lu&quot;&gt;农家一碗香（村驴）&lt;a class=&quot;zola-anchor&quot; href=&quot;#nong-jia-yi-wan-xiang-cun-lu&quot; aria-label=&quot;Anchor link for: nong-jia-yi-wan-xiang-cun-lu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主配料
&lt;ul&gt;
&lt;li&gt;鸡蛋，猪肉，螺丝椒&lt;&#x2F;li&gt;
&lt;li&gt;豆豉，葱姜蒜，小米辣&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;锅中适量油，放入鸡蛋 3-4 个（不打散）煎熟，捣成大块盛出备用&lt;&#x2F;li&gt;
&lt;li&gt;辣椒切滚刀块锅中煸炒盛出备用&lt;&#x2F;li&gt;
&lt;li&gt;锅中适量油，放入五花肉煸炒，放入豆豉，葱姜蒜，小米辣，螺丝椒煸炒&lt;&#x2F;li&gt;
&lt;li&gt;加入生抽，老抽，耗油，糖，鸡精，鸡蛋翻炒均匀出锅&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;rou-mo-qie-zi-cun-lu&quot;&gt;肉沫茄子（村驴）&lt;a class=&quot;zola-anchor&quot; href=&quot;#rou-mo-qie-zi-cun-lu&quot; aria-label=&quot;Anchor link for: rou-mo-qie-zi-cun-lu&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;主配料
&lt;ul&gt;
&lt;li&gt;蒜沫，葱花， 香菜沫，姜丝&lt;&#x2F;li&gt;
&lt;li&gt;茄子，猪肉糜，青红辣椒圈&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;锅中底油，茄子切段放入锅中焖煎（4-5 分钟）&lt;&#x2F;li&gt;
&lt;li&gt;锅留底油，煸炒肉糜肉酥吐油，放入黄豆酱姜丝煸炒，烹料酒，老抽生抽热水，加入鸡精，盐，糖，耗油，焖 8 分钟&lt;&#x2F;li&gt;
&lt;li&gt;放入青红辣椒，再焖 1 分钟，勾芡后放入葱花蒜沫香菜沫出锅&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cui-pi-wu-hua-rou&quot;&gt;脆皮五花肉&lt;a class=&quot;zola-anchor&quot; href=&quot;#cui-pi-wu-hua-rou&quot; aria-label=&quot;Anchor link for: cui-pi-wu-hua-rou&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;盐4，五香粉3，孜然粉3 黄酒腌肉&lt;&#x2F;li&gt;
&lt;li&gt;脆皮水：
水 50g，盐 4g，小苏打 3g，面碱 4g&lt;&#x2F;li&gt;
&lt;li&gt;肉穿刺，刷白醋，脆皮水两遍，隔夜风干&lt;&#x2F;li&gt;
&lt;li&gt;表面抹白醋，粗盐，160度 50 分钟，230度 15 分钟&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;lu-rou-fan-lai-pi-hou-ban&quot;&gt;卤肉饭（赖皮猴版）&lt;a class=&quot;zola-anchor&quot; href=&quot;#lu-rou-fan-lai-pi-hou-ban&quot; aria-label=&quot;Anchor link for: lu-rou-fan-lai-pi-hou-ban&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;五花肉
猪棒骨
清水12斤
姜片60克
葱段60克
香叶两片
桂皮6克
良姜7.5克
草果3克
拍破祛仔
丁香3粒
白寇一克
八角1.5克
花椒1克
小茴香一克
盐30克
煮一个小时，切成 1.5cm 宽小长方条备用&lt;&#x2F;li&gt;
&lt;li&gt;红葱头80克切丝,蒜片20克，干虾米 15g，锅中100g油炸香，炸成焦糖色，&lt;&#x2F;li&gt;
&lt;li&gt;黄冰糖60克，酱油160克，绍兴酒100克，开大火熬化至起小泡。放入猪肉，耗油30克，虾米葱蒜酥，放入卤肉汤，中小火煮30分钟&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;lu-rou-fan-zhan-mu-shi&quot;&gt;卤肉饭（詹姆士）&lt;a class=&quot;zola-anchor&quot; href=&quot;#lu-rou-fan-zhan-mu-shi&quot; aria-label=&quot;Anchor link for: lu-rou-fan-zhan-mu-shi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;p&gt;材料：蒜头6颗、红葱头6颗、葱2根、猪五花肉丝1公斤、黑糖1匙、蚝油2匙、酱油&lt;&#x2F;p&gt;
&lt;p&gt;1.五花肉切条倒入锅内，将猪油煸炒出来&lt;&#x2F;p&gt;
&lt;p&gt;2.外表呈现熟的状态下，先加入红葱头煸炒出香味，然后再倒入蒜、葱、及1匙黑糖&lt;&#x2F;p&gt;
&lt;p&gt;3.锅内加入2匙蚝油、少许酱油后，拌炒出酱香味&lt;&#x2F;p&gt;
&lt;p&gt;4.加入米酒后，倒入水淹至猪肉表面&lt;&#x2F;p&gt;
&lt;p&gt;5.撒入白胡椒粉，盖锅熬煮25分钟，完成&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>Fisrt Blog</title>
		<published>2023-05-22T00:00:00+00:00</published>
		<updated>2025-09-08T00:00:00+00:00</updated>
		<link href="https://shiyang07ca.github.io/posts/0001-fisrt-blog/" type="text/html"/>
		<id>https://shiyang07ca.github.io/posts/0001-fisrt-blog/</id>
		<content type="html">&lt;h1 id=&quot;fisrt-blog&quot;&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;shiyang07ca&#x2F;shiyang07ca.github.io&#x2F;issues&#x2F;1&quot;&gt;Fisrt Blog&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fisrt-blog&quot; aria-label=&quot;Anchor link for: fisrt-blog&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;p&gt;Test update&lt;&#x2F;p&gt;
&lt;h1 id=&quot;test-style&quot;&gt;Test Style&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-style&quot; aria-label=&quot;Anchor link for: test-style&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;layer&quot;&gt;Layer&lt;a class=&quot;zola-anchor&quot; href=&quot;#layer&quot; aria-label=&quot;Anchor link for: layer&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h1 id=&quot;second&quot;&gt;Second&lt;a class=&quot;zola-anchor&quot; href=&quot;#second&quot; aria-label=&quot;Anchor link for: second&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;test-config-update&quot;&gt;Test config update&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-config-update&quot; aria-label=&quot;Anchor link for: test-config-update&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;test-label&quot;&gt;Test label&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-label&quot; aria-label=&quot;Anchor link for: test-label&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
</content>
	</entry>
</feed>
